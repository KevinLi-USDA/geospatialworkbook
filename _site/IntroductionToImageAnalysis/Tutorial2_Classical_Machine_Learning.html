<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.11.2 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Premeeting - Geospatial Workbook</title>
<meta name="description" content="Tutorial on Informatics for Geospatial Information">


  <meta name="author" content="Kerrie Geil">


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Geospatial Workbook">
<meta property="og:title" content="Premeeting">
<meta property="og:url" content="http://localhost:4000/IntroductionToImageAnalysis/Tutorial2_Classical_Machine_Learning.html">




  <meta property="og:image" content="http://localhost:4000/assets/images/margaret-weir-GZyjbLNOaFg-unsplash_dark.jpg">



  <meta name="twitter:site" content="@isugif">
  <meta name="twitter:title" content="Premeeting">
  <meta name="twitter:description" content="Tutorial on Informatics for Geospatial Information">
  <meta name="twitter:url" content="http://localhost:4000/IntroductionToImageAnalysis/Tutorial2_Classical_Machine_Learning.html">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="http://localhost:4000/assets/images/margaret-weir-GZyjbLNOaFg-unsplash_dark.jpg">
  

  
    <meta name="twitter:creator" content="@someone">
  







  

  


<link rel="canonical" href="http://localhost:4000/IntroductionToImageAnalysis/Tutorial2_Classical_Machine_Learning.html">







  <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Person",
      "name": "",
      "url": "http://localhost:4000",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Geospatial Workbook Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E6BZVYF8ZY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E6BZVYF8ZY');
</script>

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="/">Geospatial Workbook</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/about.html" >About</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/list.html" >Index</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/glossary.html" >Glossary</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/people.html" >People</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/contributing.html" >Contribute</a>
            </li>
          
        </ul>
        
        <button class="search__toggle" type="button">
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle Menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
  











<div class="page__hero--overlay"
  style="background-color: 444444; background-image: url('/assets/images/margaret-weir-GZyjbLNOaFg-unsplash_dark.jpg');"
>
  
    <div class="wrapper">
      <h1 id="page-title" class="page__title" itemprop="headline">
        
          Premeeting

        
      </h1>
      
      
      
    </div>
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/people/KerrieGeil.png" alt="Kerrie Geil" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Kerrie Geil</h3>
    
    
      <p class="author__bio" itemprop="description">
        Kerrie is an ARS SCINet postdoc in the research group of Dr. Deb Peters in Las Cruces, NM. Her M.S. and Ph.D. degrees are in Atmospheric Sciences and her research background is in climate modeling.
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      

      
        <li>
          <a href="mailto:mailto:someone@iastate.edu">
            <meta itemprop="email" content="mailto:someone@iastate.edu" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/someone" itemprop="sameAs">
            <i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

<!-- Create a 2nd author for tutorials -->



<div itemscope itemtype="http://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name"></h3>
    
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Premeeting">
    
    
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
        <h1 id="tutorial-2-classical-machine-learning-fundamentals">Tutorial 2: Classical Machine Learning Fundamentals</h1>
<h2 id="laura-e-boucheron-electrical--computer-engineering-nmsu">Laura E. Boucheron, Electrical &amp; Computer Engineering, NMSU</h2>
<h3 id="october-2020">October 2020</h3>
<p>Copyright (C) 2020  Laura E. Boucheron</p>

<p>This information is free; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.</p>

<p>This work is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this work in a file <code class="language-plaintext highlighter-rouge">COPYING.TXT</code>; if not, If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>

<h2 id="overview">Overview</h2>
<p>In this tutorial, we present a brief overview of classical machine learning concepts as applicable to image classification applications.  Completion of this tutorial should give participants the basic background and terminology necessary for an understanding of the basics of classical machine learning as applied to image classification.  In this tutorial, we will develop a classical machine learning algorithm capable of discriminating between objects present in an image.</p>

<p>This tutorial contains 5 sections:</p>
<ul>
  <li><strong>Section 0: Preliminaries</strong>: some notes on using this notebook, how to download the image dataset that we will use for this tutorial, and import commands for the libraries necessary for this tutorial</li>
  <li><strong>Section 1: Working with the CalTech101 Dataest</strong>: how to traverse and use the directory structure and files provided in the CalTech101 Dataset</li>
  <li><strong>Section 2: Feature Extraction</strong>: examples of extraction of different feature categories from images, including color, region, and texture features
    <ul>
      <li><strong>Section 2.1: Color Features</strong>: statistics of the color within an image object</li>
      <li><strong>Section 2.2: Region Features</strong>: measures of the size and shape of the image object</li>
      <li><strong>Section 2.3: Texture Features</strong>: measures of the distribution of intensities within the image object</li>
    </ul>
  </li>
  <li><strong>Section 3: Setting up a Feature Matrix and Label Vector</strong>: aggregating features into a feature matrix in the format expected by machine learning algorithms along with definition of a label vector</li>
  <li><strong>Section 4: Classification</strong>: examples of common classification methods, including training and testing on the CalTech101 dataset</li>
</ul>

<p>There are subsections with the heading “<strong><span style="color:Green"> Your turn: </span></strong>” throughout this tutorial in which you will be asked to apply what you have learned.</p>

<h1 id="section-0-preliminaries">Section 0: Preliminaries</h1>
<h2 id="section-01-a-note-on-jupyter-notebooks">Section 0.1: A Note on Jupyter Notebooks</h2>

<p>There are two main types of cells in this notebook: code and markdown (text).  You can add a new cell with the plus sign in the menu bar above and you can change the type of cell with the dropdown menu in the menu bar above.  As you complete this tutorial, you may wish to add additional code cells to try out your own code and markdown cells to add your own comments or notes.</p>

<p>Markdown cells can be augmented with a number of text formatting features, including</p>
<ul>
  <li>bulleted</li>
  <li>lists</li>
</ul>

<p>embedded $\LaTeX$, monotype specification of <code class="language-plaintext highlighter-rouge">code syntax</code>, <strong>bold font</strong>, and <em>italic font</em>.  There are many other features of markdown cells–see the jupyter documentation for more information.</p>

<p>You can edit a cell by double clicking on it.  If you double click on this cell, you can see how to implement the various formatting referenced above.  Code cells can be run and markdown cells can be formatted using Shift+Enter or by selecting the Run button in the toolbar above.</p>

<p>Once you have completed (all or part) of this notebook, you can share your results with colleagues by sending them the <code class="language-plaintext highlighter-rouge">.ipynb</code> file.  Your colleagues can then open the file and will see your markdown and code cells as well as any results that were printed or displayed at the time you saved the notebook.  If you prefer to send a notebook without results displayed (like this notebook appeared when you downloaded it), you can select (“Restart &amp; Clear Output”) from the Kernel menu above.  You can also export this notebook in a non-executable form, e.g., <code class="language-plaintext highlighter-rouge">.pdf</code> through the File, Save As menu.</p>

<h2 id="section-02-downloading-images">Section 0.2 Downloading Images</h2>
<p>In this tutorial, we will use the CalTech101 dataset, which is a standard dataset used for image classification.  You can find important information about this dataset at (http://www.vision.caltech.edu/Image_Datasets/Caltech101/).  From that webpage, download the dataset itself (http://www.vision.caltech.edu/Image_Datasets/Caltech101/101_ObjectCategories.tar.gz) (126 MB) and also the annotations (http://www.vision.caltech.edu/Image_Datasets/Caltech101/Annotations.tar) (13 MB) which will allow us to focus our feature extraction on only the objects in the images.</p>

<p>Extract the image dataset and the annotations in your working directory.  The images will extract to a <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code> directory, under which there are 102 directories named according to the object contained in the image (e.g., <code class="language-plaintext highlighter-rouge">accordion/</code> or <code class="language-plaintext highlighter-rouge">pizza/</code>), under which are files with file format <code class="language-plaintext highlighter-rouge">image_XXXX.jpg</code>, where <code class="language-plaintext highlighter-rouge">XXXX</code> is a four digit number.  The annotations will extract to an <code class="language-plaintext highlighter-rouge">Annotations/</code> directory, underneath which there are 101 directories named the same categories (for the most part) as the <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code> categories, under which  are files <code class="language-plaintext highlighter-rouge">annotation_XXXX.mat</code>, where <code class="language-plaintext highlighter-rouge">XXXX</code> is a four digit number.  There are also 5 other files in the <code class="language-plaintext highlighter-rouge">Annotations/</code> directory.  In order to make subsequent code run more easily:</p>
<ul>
  <li>Within <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code>:
    ◦ Delete directory <code class="language-plaintext highlighter-rouge">BACKGROUND_Google/</code></li>
  <li>Within <code class="language-plaintext highlighter-rouge">Annotations/</code>:
    ◦ Delete <code class="language-plaintext highlighter-rouge">*.mat</code>
    ◦ Delete <code class="language-plaintext highlighter-rouge">README*</code>
    ◦ Move (rename) directory <code class="language-plaintext highlighter-rouge">Airplanes_Side_2/</code> to <code class="language-plaintext highlighter-rouge">airplanes/</code>
    ◦ Move (rename) directory <code class="language-plaintext highlighter-rouge">Faces_2/</code> to <code class="language-plaintext highlighter-rouge">Faces/</code>
    ◦ Move (rename) directory <code class="language-plaintext highlighter-rouge">Faces_3/</code> to <code class="language-plaintext highlighter-rouge">Faces_easy/</code>
    ◦ Move (rename) directory <code class="language-plaintext highlighter-rouge">Motorbikes_16/</code> to <code class="language-plaintext highlighter-rouge">Motorbikes/</code></li>
</ul>

<h2 id="section-03a-import-necessary-libraries-for-users-using-a-local-machine">Section 0.3a Import Necessary Libraries (For users using a local machine)</h2>
<p>Here, at the top of the code, we import all the libraries necessary for this tutorial.  We will introduce the functionality of any new libraries throughout the tutorial, but include all import statements here as standard coding practice.  We include a brief comment after each library here to indicate its main purpose within this tutorial.</p>

<p>It would be best to run this next cell before the workshop starts to make sure you have all the necessary packages installed on your machine.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span> <span class="c1"># visualization
</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span> <span class="c1"># mathematical and scientific functions
</span><span class="kn">import</span> <span class="nn">os</span> <span class="c1"># interaction with OS for file manipulation
</span><span class="kn">import</span> <span class="nn">glob</span> <span class="c1"># a nice unix-style interface for path and file manipulation
</span><span class="kn">import</span> <span class="nn">imageio</span> <span class="c1"># image I/O
</span><span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="c1"># measure region properties
</span><span class="kn">import</span> <span class="nn">skimage.feature</span> <span class="c1"># measure region properties
</span><span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="n">spio</span> <span class="c1"># ability to load Matlab .mat files
</span><span class="kn">import</span> <span class="nn">sklearn</span> <span class="c1"># common classifiers
</span><span class="kn">import</span> <span class="nn">sklearn.metrics</span> <span class="c1"># classification metrics
</span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span> <span class="c1"># the support vector machine classifier
</span>
<span class="c1"># format matplotlib options
</span><span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="n">update</span><span class="p">({</span><span class="s">'font.size'</span><span class="p">:</span> <span class="mi">20</span><span class="p">})</span>
</code></pre></div></div>

<h2 id="section-03b-build-the-conda-environment-for-users-using-the-ars-hpc-ceres-with-jupyterlab">Section 0.3b Build the Conda Environment (For users using the ARS HPC Ceres with JupyterLab)</h2>
<p>Open a terminal from inside JupyterLab (File &gt; New &gt; Terminal) and type the following commands</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source activate
conda create --name NMSU-AI-Workshop_image-processing python=3.7 numpy matplotlib imageio scikit-image ipykernel -y
</code></pre></div></div>
<p>It may take 5 minutes to build the Conda environment.</p>

<p>When the environment finishes building, select this environment as your kernel in your Jupyter Notebook (click top right corner where you see Python 3, select your new kernel from the dropdown menu, click select)</p>

<p>You will want to do this BEFORE the workshop starts.</p>

<h1 id="section-1-working-with-the-caltech101-dataset">Section 1: Working with the CalTech101 Dataset</h1>
<h2 id="section-11-exploring-the-images">Section 1.1: Exploring the Images</h2>
<p>In the previous tutorial, we were working with only two images.  There are more than 8000 images in 101 different directories in the CalTech101 dataset.  We thus need to develop ways to efficiently loop over larger image datasets and access the images without hard coding the image filenames.</p>

<p>Here, we will use the <code class="language-plaintext highlighter-rouge">glob</code> library to store directory names and filenames in a list.  You can store the directory names of the CalTech101 dataset in a list with <code class="language-plaintext highlighter-rouge">categories=sorted(glob.glob('101_ObjectCategories/*')</code>.  This list now gives you a means to loop over the 101 different categories of objects in that <code class="language-plaintext highlighter-rouge">categories[k]</code> is the <code class="language-plaintext highlighter-rouge">k</code>-th category name as a string (including the string <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code> prepended to the category name).  A few other notes:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">glob.glob</code> returns an unordered list.  We wrap a <code class="language-plaintext highlighter-rouge">sorted</code> around the <code class="language-plaintext highlighter-rouge">glob.glob</code> command to return the directories or filenames in the usual alphabetical order</li>
  <li><code class="language-plaintext highlighter-rouge">glob.glob</code> returns a list with the full pathname (from where you searched) prepended.  In this case, since we search from the directory just under <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code>, the string <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code> will be prepended to each of the 101 object categories.  If we had searched using a more complete path, e.g., <code class="language-plaintext highlighter-rouge">categories=sorted(glob.glob('/home/user/tutorials/101_ObjectCategories/*')</code>, the full specified path would be prepended to each of the categories.  The full pathname is very helpful if you need to access something within that path since you don’t need to manually preprend the full path.</li>
  <li><code class="language-plaintext highlighter-rouge">os.path.basename</code> will strip off only the base directory or filename from the full path if you don’t want the full path.</li>
</ul>

<p>Using this list <code class="language-plaintext highlighter-rouge">categories</code>, we can read in the first image (<code class="language-plaintext highlighter-rouge">image_0001.jpg</code>) from each of the 101 categories and display that image in one location of an $11\times10$ subplot.  We can also title each of those locations of the subplot with the category name.  We note that this code is not robust in the sense that we are relying on the existence of a specific filename format under each of the directories in <code class="language-plaintext highlighter-rouge">101_ObjectCategories</code>.  We will work with more robust means to traverse the files that exist in each directory in later portions of this tutorial.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/*'</span><span class="p">))</span>

<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">45</span><span class="p">))</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">category</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">categories</span><span class="p">):</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">category</span><span class="o">+</span><span class="s">'/image_0001.jpg'</span><span class="p">))</span>  <span class="c1"># category has full path
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="s">'gray'</span><span class="p">)</span> <span class="c1"># change colormap to be gray
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># access the k-th supblot in an 11x10 grid
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> 
    <span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">basename</span><span class="p">(</span><span class="n">category</span><span class="p">))</span> <span class="c1"># strip off basename for title
</span></code></pre></div></div>

<p><img src="Tutorial2_Classical_Machine_Learning_files/Tutorial2_Classical_Machine_Learning_7_0.png" alt="png" /></p>

<h2 id="section-12-exploring-the-annotations">Section 1.2 Exploring the Annotations</h2>
<h3 id="section-121-plotting-the-annotations-as-a-boundary-over-the-image">Section 1.2.1 Plotting the annotations as a boundary over the image</h3>
<p>The annotations are stored in Matlab’s <code class="language-plaintext highlighter-rouge">.mat</code> format, which the <code class="language-plaintext highlighter-rouge">scipy.io</code> library in python can load.  Above, we have imported <code class="language-plaintext highlighter-rouge">scipy.io</code> as <code class="language-plaintext highlighter-rouge">spio</code>.  The image annotations can be read in with the <code class="language-plaintext highlighter-rouge">spio.loadmat</code> function, e.g., <code class="language-plaintext highlighter-rouge">ann=spio.loadmat('filename.mat')</code>.  The <code class="language-plaintext highlighter-rouge">spio.loadmat</code> function returns a dictionary with variable names as keys.  In the CalTech101 annotations, dictionary entry <code class="language-plaintext highlighter-rouge">ann['box_coord']</code> is a $1\times4$ vector of bounding box coordinates and <code class="language-plaintext highlighter-rouge">ann['obj_contour']</code> is a $2\times K$ vector of pixel locations which outline the contour of the object, where $K$ will be different for different annotations.</p>

<p>As an example, we read in <code class="language-plaintext highlighter-rouge">Annotations/emu/annotation_0001.mat</code> and display <code class="language-plaintext highlighter-rouge">box_coord</code> and <code class="language-plaintext highlighter-rouge">obj_contour</code>.  The object contour points <code class="language-plaintext highlighter-rouge">obj_contour</code> are (for reasons unbeknownst to us) offset by the upper left <code class="language-plaintext highlighter-rouge">box_coord</code> coordinates.</p>

<p>As a further example, we read in the corresponding image <code class="language-plaintext highlighter-rouge">101_ObjectCategories/emu/image_0001.jpg</code> and display it.  On top of that image, we plot the annotation outline with a basic plot command <code class="language-plaintext highlighter-rouge">plt.plot(ann['obj_contour'][0,:]+ann['box_coord'][0,2]-1,ann['obj_contour'][1,:]+ann['box_coord'][0,0]-1,'w')</code>.  A few notes:</p>
<ul>
  <li>We offset the contour points by the upper left corner of the bounding box.</li>
  <li>We need to offset all the points by -1 due to the difference in indexing in Matlab (starting at 1) and python (starting at 0).  Since the annotations were output in Matlab, the indexing is consistent with Matlab convention.</li>
  <li>We note that the annotations appear to be provided in standard Euclidean coordinates, i.e., assuming an x-axis (column), y-axis (row) ordering.</li>
  <li>We note that since we first displayed the image using <code class="language-plaintext highlighter-rouge">plt.imshow</code>, the axes for the figure are assumed to have the origin in the top left.  The <code class="language-plaintext highlighter-rouge">plt.plot</code> command will use the plotting coordinate conventions of x-axis, y-axis, but will follow the origin set up by the image visualization.</li>
  <li>All of the aforementioned observations were noted based on exploration of visualization of the annotations and hard-learned lessons regarding conventions in coordinate systems for images and image metadata.  Some insights were additionally gathered from the <code class="language-plaintext highlighter-rouge">show_annotation.m</code> file from http://www.vision.caltech.edu/Image_Datasets/Caltech101/show_annotation.m (the link appears to be currently broken, however).</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>

<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'box_coord'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">'obj_contour'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">])</span>

<span class="c1"># ann['box_coord'] appears to have the bounding box vertices specified as 
# [row_min, row_max, col_min, col_max] or [y_min, y_max, x_min, x_max]
# ann['obj_contour'] appears to have the column indices (x-axis) in the zeroth row and the 
# row indices (y-axis) in the first row
</span>
<span class="c1"># plot expects the x-axis first and the y-axis second (col first, row second)
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
         <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">'w'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Annotated Emu'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>box_coord
[[  7 247  72 293]]
obj_contour
[[ 16.57982456  14.46578947  11.50614035   9.39210526  18.27105263
   29.26403509  36.8745614   39.83421053  47.86754386  36.45175439
   31.37807018  43.21666667  77.46403509 104.52368421 127.77807018
  159.06578947 189.93070175 204.30614035 215.29912281 213.60789474
  163.29385965 141.30789474 123.12719298  92.68508772  74.92719298
   50.82719298  19.11666667   6.85526316   6.00964912  17.4254386
   17.4254386 ]
 [ 78.93070175  53.98508772  28.19385965  10.43596491   2.8254386
    5.3622807   13.81842105  25.23421053  34.95877193  35.38157895
   42.99210526  81.04473684 119.94298246 117.82894737 123.3254386
  141.08333333 168.98859649 196.47105263 229.87280702 240.02017544
  240.44298246 217.18859649 240.44298246 240.02017544 232.83245614
  223.10789474 193.51140351 163.49210526 113.60087719  78.50789474
   78.50789474]]
</code></pre></div></div>

<p><img src="Tutorial2_Classical_Machine_Learning_files/Tutorial2_Classical_Machine_Learning_9_1.png" alt="png" /></p>

<h3 id="section-122-some-common-coordinate-issues-that-may-be-encountered-with-annotations">Section 1.2.2 Some common coordinate issues that may be encountered with annotations</h3>
<p>We noted above that since we first displayed the image using <code class="language-plaintext highlighter-rouge">plt.imshow</code>, the axes for the figure are assumed to have the origin in the top left.  The <code class="language-plaintext highlighter-rouge">plt.plot</code> command will use the plotting coordinate conventions of x-axis, y-axis, but will follow the origin set up by the image visualization.  We further explore this issue by using the same plotting command <code class="language-plaintext highlighter-rouge">plt.plot(ann['obj_contour'][0,:]+ann['box_coord'][0,2]-1,ann['obj_contour'][1,:]+ann['box_coord'][0,0]-1,'r')</code> as above, but without first visualizing the image.  This means that the <code class="language-plaintext highlighter-rouge">plt.plot</code> command is expected to use the plotting coordinate conventions of x-axis, y-axis and have the origin in the bottom left.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
         <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Emu Annotation Alone'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'image'</span><span class="p">)</span> <span class="c1"># this just makes the aspect ratio consistent rather than "stretching" the image
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="Tutorial2_Classical_Machine_Learning_files/Tutorial2_Classical_Machine_Learning_11_0.png" alt="png" /></p>

<h4 id="reversing-coordinates">Reversing coordinates</h4>
<p>A very common mistake in plotting (x,y) coordinates on top of images is accidentally reversing the order of the coordinates.  Given the rotated coordinate system used for images, this can cause a common “rotation” of expected results.  If we accidentally plotted the annotation in row, column order, we would achieve something like follows.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
         <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">'w'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Annotated Emu'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="Tutorial2_Classical_Machine_Learning_files/Tutorial2_Classical_Machine_Learning_13_0.png" alt="png" /></p>

<h3 id="section-123-computing-a-binary-object-mask-from-the-annotation-data">Section 1.2.3 Computing a binary object mask from the annotation data</h3>
<p>You can use the object contour outline to define a binary image image mask with <code class="language-plaintext highlighter-rouge">r,c = skimage.draw.polygon(ann['obj_contour'][1,:]+ann['box_coord'][0,0]-1,ann['obj_contour'][0,:]+ann['box_coord'][0,2]-1,(M,N)); A=np.zeros(M,N); A[r,c]=1;</code> (note that the object contour indices are swapped here versus the plot command used above due to the difference in coordinate systems of image versus plot) where <code class="language-plaintext highlighter-rouge">M</code>, <code class="language-plaintext highlighter-rouge">N</code> are the dimensions of the image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
         <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">I</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Original Emu Image'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s">'gray'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Binary Emu Mask'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="Tutorial2_Classical_Machine_Learning_files/Tutorial2_Classical_Machine_Learning_15_0.png" alt="png" /></p>

<h2 id="-your-turn-"><span style="color:Green"> Your turn: </span></h2>
<p>Using what you have learned about using lists to loop over categories, load the first annotation (<code class="language-plaintext highlighter-rouge">annotation_0001.mat</code>) from each of the 101 categories, use the corresponding <code class="language-plaintext highlighter-rouge">obj_contour</code> to define an object mask, and display that mask in one location of an $11\times10$  subplot.  Title each of those locations of the subplot with the category name.  You might find it handy to read in the image corresponding to the annotation in order to easily get the dimensions.  The visualizations from the previous part can be used here to spot-check the correctness of the annotations.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h2 id="section-2-feature-extraction">Section 2: Feature Extraction</h2>
<p>In this section we will define several functions designed to extract different categories of features from images.  These functions will span several common categories of features, but are by no means a comprehensive list.  These feature extraction methods are illustration of so-called “hand-designed” features.  These are features that are specifically implemented as features that are expected to be helpful for discriminating between different image categories.</p>

<h3 id="section-21-color-features">Section 2.1 Color Features</h3>
<p>In this section, we will extract a set of features designed to charaterize the colors present in an image.  We use the annotation mask as defined above to focus our attention on features only within the object of interest rather than features of the entire image.</p>

<h3 id="section-211-defining-color-statistics">Section 2.1.1 Defining color statistics</h3>
<p>Here we create a function <code class="language-plaintext highlighter-rouge">f,fnames=extract_color_features_rgb(im,mask)</code> with inputs <code class="language-plaintext highlighter-rouge">im</code>, the image from which to extract features, and the binary annotation mask, <code class="language-plaintext highlighter-rouge">mask</code>.  Outputs will be a length-15 feature vector <code class="language-plaintext highlighter-rouge">f</code> describing statistics of the colors within the image object and a length-15 list <code class="language-plaintext highlighter-rouge">fnames</code> with the feature names.  We extract statistics from the red, green, and blue channels of the image.  From each channel, we compute the mean, standard deviation, median, min, and max value of pixels <em>within the object mask</em>.  We order the features by channel first in the order given above and by statistic second in the order given above (i.e., the first and second features will be mean and standard deviation of the red channel).  We assign brief, descriptive strings for each feature and store those in <code class="language-plaintext highlighter-rouge">fnames</code> (e.g., <code class="language-plaintext highlighter-rouge">'R_mean'</code>, and <code class="language-plaintext highlighter-rouge">'R_std'</code> as names for the first two features).  Note that we also need to take care of the situation in which the image is a grayscale image, i.e., only one channel by using the <code class="language-plaintext highlighter-rouge">skimage.color.gray2rgb</code> function to convert to an RGB image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">gray2rgb</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span>
    
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">mean</span><span class="p">(),</span> <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">std</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]),</span> \
                     <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">min</span><span class="p">(),</span> <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">max</span><span class="p">()])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">mean</span><span class="p">(),</span> <span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">std</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]),</span> \
                     <span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">min</span><span class="p">(),</span>  <span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">max</span><span class="p">()])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">mean</span><span class="p">(),</span> <span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">std</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]),</span> \
                     <span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">min</span><span class="p">(),</span>  <span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">max</span><span class="p">()])</span>

    <span class="n">fnames</span> <span class="o">=</span> <span class="p">(</span><span class="s">'R_mean'</span><span class="p">,</span><span class="s">'R_std'</span><span class="p">,</span><span class="s">'R_median'</span><span class="p">,</span><span class="s">'R_min'</span><span class="p">,</span><span class="s">'R_max'</span><span class="p">,</span>\
              <span class="s">'G_mean'</span><span class="p">,</span><span class="s">'G_std'</span><span class="p">,</span><span class="s">'G_median'</span><span class="p">,</span><span class="s">'G_min'</span><span class="p">,</span><span class="s">'G_max'</span><span class="p">,</span>\
              <span class="s">'B_mean'</span><span class="p">,</span><span class="s">'B_std'</span><span class="p">,</span><span class="s">'B_median'</span><span class="p">,</span><span class="s">'B_min'</span><span class="p">,</span><span class="s">'B_max'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">fnames</span>
</code></pre></div></div>

<h3 id="section-212-extracting-color-statistics">Section 2.1.2 Extracting color statistics</h3>
<p>Using <code class="language-plaintext highlighter-rouge">101_ObjectCategories/emu/image_0001.jpg</code> as the input image <code class="language-plaintext highlighter-rouge">im</code> and <code class="language-plaintext highlighter-rouge">Annotations/emu/annotation_0001.mat</code> as the annotation mask <code class="language-plaintext highlighter-rouge">mask</code>, we use the <code class="language-plaintext highlighter-rouge">extract_color_features_rgb</code> function and print out the <code class="language-plaintext highlighter-rouge">f</code> vector and the <code class="language-plaintext highlighter-rouge">fnames</code> list.  These features may not mean much to us as printed, but such a printed output can be used as a sanity check.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>
<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
<span class="n">f</span><span class="p">,</span><span class="n">fnames</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'feature vector'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'feature names'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature vector
[ 89.66263904  41.77544731  85.           3.         255.
  60.43520174  36.47920188  53.           0.         250.
  70.16239913  37.50792712  63.           0.         255.        ]
feature names
('R_mean', 'R_std', 'R_median', 'R_min', 'R_max', 'G_mean', 'G_std', 'G_median', 'G_min', 'G_max', 'B_mean', 'B_std', 'B_median', 'B_min', 'B_max')
</code></pre></div></div>

<h2 id="-your-turn--1"><span style="color:Green"> Your turn: </span></h2>
<p>Create a feature extraction function <code class="language-plaintext highlighter-rouge">f,fnames=extract_color_features_hsv(im,mask)</code> with inputs <code class="language-plaintext highlighter-rouge">im</code>, the image from which to extract features, and the binary annotation mask, <code class="language-plaintext highlighter-rouge">mask</code>.  Outputs will be a length-15 feature vector <code class="language-plaintext highlighter-rouge">f</code> describing statistics of the colors in HSV space within the image object and a length-15 list <code class="language-plaintext highlighter-rouge">fnames</code> with the feature names.  Extract statistics from the hue, saturation, and value channels of the image.  From each channel, compute the mean, standard deviation, median, min, and max value of pixels within the object mask.  In order to convert between the RGB and HSV color space, use the command <code class="language-plaintext highlighter-rouge">skimage.color.rgb2hsv</code>.  Order the features by channel first in the order given above and by statistic second in the order given above (i.e., the first and second features will be mean and standard deviation of the hue channel).  Assign brief, descriptive strings for each feature and store those in <code class="language-plaintext highlighter-rouge">fnames</code> (e.g., <code class="language-plaintext highlighter-rouge">'H_mean'</code>, and <code class="language-plaintext highlighter-rouge">'H_std'</code> as names for the first two features).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h3 id="section-22-region-features">Section 2.2 Region features</h3>
<p>In this section, we will extract a set of features designed to characterize the size and shape of an image object.  We use the annotation mask as defined above to define the object of interest.</p>

<h3 id="section-221-defining-region-features">Section 2.2.1: Defining region features</h3>
<p>We will use the <code class="language-plaintext highlighter-rouge">skimage.measure.regionprops</code> function to compute a list of region-based features in the <code class="language-plaintext highlighter-rouge">extract_region_features</code> function below.  We will not use all of the features available in <code class="language-plaintext highlighter-rouge">skimage.measure.regionprops</code> because some of those features may not be useul in our image classification situation.  For example, the centroid of the object or the orientation of the object may bias the classifier to translation or rotation variance.  In all subsequent discussion, the term “region” is used to denote the annotated region in an image.  The 19 features extracted below are measures of region characteristics of a region, including:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">'area'</code>: the number of pixels in the region</li>
  <li><code class="language-plaintext highlighter-rouge">'bbox_area'</code>: the number of pixels in the bounding box that contains the region</li>
  <li><code class="language-plaintext highlighter-rouge">'convex_area'</code>: the number of pixels in the convex hull of the region (think about “snapping a rubber band” around the region–that is the convex hull)</li>
  <li><code class="language-plaintext highlighter-rouge">'eccentricity'</code>: eccentricity of the ellipse with the same second order moments as the region</li>
  <li><code class="language-plaintext highlighter-rouge">'equivalent_diameter'</code>: the diameter of the circle with the same area as the region</li>
  <li><code class="language-plaintext highlighter-rouge">'euler_number'</code>: a measure of the “holy-ness” of the region</li>
  <li><code class="language-plaintext highlighter-rouge">'extent'</code>: ratio of area of the region to area of the bounding box</li>
  <li><code class="language-plaintext highlighter-rouge">'filled_area'</code>: the number of pixels in the region if the holes were filled</li>
  <li><code class="language-plaintext highlighter-rouge">'major_axis_length'</code>: the length of the major axis of the ellipse with the same second order moments as the region</li>
  <li><code class="language-plaintext highlighter-rouge">'minor_axis_length'</code>: the length of the minor axis of the ellipse with the same second order moments as the region</li>
  <li><code class="language-plaintext highlighter-rouge">'moments_hu'</code>: seven weighted moments (averages) of the region, designed to be invariant to rotation, scale, and translation of the region</li>
  <li><code class="language-plaintext highlighter-rouge">'perimeter'</code>: the length of the perimeter of the object (measured in number of pixels)</li>
  <li><code class="language-plaintext highlighter-rouge">'solidity'</code>: ratio of area of the region to convex area of the region</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_region_features_try1</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
    <span class="n">props</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">measure</span><span class="p">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">area</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bbox_area</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">convex_area</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">eccentricity</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">equivalent_diameter</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">euler_number</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">extent</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">filled_area</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">major_axis_length</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">minor_axis_length</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">moments_hu</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">perimeter</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">solidity</span><span class="p">])</span>

    <span class="n">fnames</span> <span class="o">=</span> <span class="p">(</span><span class="s">'area'</span><span class="p">,</span> <span class="s">'bbox_area'</span><span class="p">,</span> <span class="s">'convex_area'</span><span class="p">,</span> <span class="s">'eccentricity'</span><span class="p">,</span>\
              <span class="s">'equivalent_diameter'</span><span class="p">,</span> <span class="s">'euler_number'</span><span class="p">,</span> <span class="s">'extent'</span><span class="p">,</span> <span class="s">'filled_area'</span><span class="p">,</span>\
              <span class="s">'major_axis_length'</span><span class="p">,</span> <span class="s">'minor_axis_length'</span><span class="p">,</span> <span class="s">'moments_hu1'</span><span class="p">,</span>\
              <span class="s">'perimeter'</span><span class="p">,</span> <span class="s">'solidity'</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span><span class="n">fnames</span>
</code></pre></div></div>

<h3 id="section-222-extracting-region-features">Section 2.2.2: Extracting region features</h3>
<p>Using <code class="language-plaintext highlighter-rouge">101_ObjectCategories/emu/image_0001.jpg</code> as the input image <code class="language-plaintext highlighter-rouge">im</code> and <code class="language-plaintext highlighter-rouge">Annotations/emu/annotation_0001.mat</code> as the annotation mask <code class="language-plaintext highlighter-rouge">mask</code>, we use the <code class="language-plaintext highlighter-rouge">extract_region_features_try1</code> function and print out the <code class="language-plaintext highlighter-rouge">f</code> vector and the <code class="language-plaintext highlighter-rouge">fnames</code> list. Depending on your version of python, you may get a deprecation warning when running the following code.  That deprecation warning is related to the issue that you will explore in the next <strong><span style="color:Green"> Your turn: </span></strong> block.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>
<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
<span class="n">f</span><span class="p">,</span><span class="n">fnames</span> <span class="o">=</span> <span class="n">extract_region_features_try1</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s">'feature vector'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'feature names'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature vector
[22925 49742 28789 0.8620919826231704 170.8479340321492 1
 0.46087813115676896 22925 270.7075275837515 137.18153400649797
 array([2.51094162e-01, 2.20473857e-02, 6.43740783e-03, 1.26777654e-03,
       2.54548085e-06, 1.25658455e-05, 2.57636709e-06])
 824.5655839020935 0.7963110910417173]
feature names
('area', 'bbox_area', 'convex_area', 'eccentricity', 'equivalent_diameter', 'euler_number', 'extent', 'filled_area', 'major_axis_length', 'minor_axis_length', 'moments_hu1', 'perimeter', 'solidity')


C:\Users\kerrielg\anaconda3\envs\aiworkshop1\lib\site-packages\ipykernel_launcher.py:8: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray
</code></pre></div></div>

<h2 id="-your-turn--2"><span style="color:Green"> Your turn: </span></h2>
<p>We are designing functions that can extract a vector of features from image regions.  What issue do you note with the feature vector that is returned by <code class="language-plaintext highlighter-rouge">extract_region_features_try1</code>?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h2 id="-your-turn--3"><span style="color:Green"> Your turn: </span></h2>
<p>Here is a modification to the region feature extraction code called simply <code class="language-plaintext highlighter-rouge">extract_region_features</code>.  Use this function to compare and contrast the output to the output from <code class="language-plaintext highlighter-rouge">extract_region_features_try1</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h3 id="section-23-texture-features">Section 2.3: Texture features</h3>
<p>In this section, we will extract a set of features designed to characterize the textures of intensities in an image.  Texture measures characterize the spatial distribution of intensities in an image.  If we think of a grayscale image as a surface where the lighter regions are raised higher than the darker regions, the distribution of those intensities would manifest as different texures if you were to run your finger across the image.  Again, we use the annotation mask as defined above to focus our attention on features only within the object of interest rather than features of the entire image.</p>

<h3 id="section-231-defining-texture-features">Section 2.3.1: Defining texture features</h3>
<p>We create a function <code class="language-plaintext highlighter-rouge">f,fnames=extract_texture_features(im,mask)</code> with inputs <code class="language-plaintext highlighter-rouge">im</code>, the image from which to extract features, and the binary annotation mask, <code class="language-plaintext highlighter-rouge">mask</code>.  This function makes use of the gray-level co-occurrence matrix (GLCM) which is a common method to extract texture features from an image.  The outputs are a length-48 feature vector <code class="language-plaintext highlighter-rouge">f</code> of co-occurrence matrix features within the image object and a length-48 list <code class="language-plaintext highlighter-rouge">fnames</code> with the feature names.</p>
<ul>
  <li>The GLCM is computed for a set of four different orientations $\theta=[0,45,90,135]$ and four different distances $d=[1,2,3,4]$ pixels and for intensities quantized to 32 levels.</li>
  <li>The average and standard deviation of GLCM features are computed across the four orientations for each distance, resulting in features that are reasonably invariant to orientation.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">im</span><span class="o">/</span><span class="mf">255.</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">I_q</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="mi">31</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">I_q</span><span class="p">[</span><span class="n">mask</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span> <span class="c1"># an intensity of 32 codes the background pixels
</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">feature</span><span class="p">.</span><span class="n">greycomatrix</span><span class="p">(</span><span class="n">I_q</span><span class="p">,</span><span class="n">distances</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>\
                                 <span class="n">angles</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span><span class="n">levels</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span>\
                                 <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">32</span><span class="p">,:,:].</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># remove statistics associated with background pixels
</span>

    <span class="n">GLCM_feats</span> <span class="o">=</span> <span class="p">{</span><span class="s">'contrast'</span><span class="p">,</span> <span class="s">'dissimilarity'</span><span class="p">,</span> <span class="s">'homogeneity'</span><span class="p">,</span> <span class="s">'energy'</span><span class="p">,</span> <span class="s">'correlation'</span><span class="p">,</span> <span class="s">'ASM'</span><span class="p">}</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fnames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">GLCM_feat</span> <span class="ow">in</span> <span class="n">GLCM_feats</span><span class="p">:</span>
        <span class="n">G_feats</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">feature</span><span class="p">.</span><span class="n">greycoprops</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">GLCM_feat</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">G_feats</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">G_feats</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">fnames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">'GLCM_'</span><span class="o">+</span><span class="n">GLCM_feat</span><span class="o">+</span><span class="s">'_d'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="s">'_mean'</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">fnames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">'GLCM_'</span><span class="o">+</span><span class="n">GLCM_feat</span><span class="o">+</span><span class="s">'_d'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="s">'_std'</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">fnames</span>
</code></pre></div></div>

<h3 id="section-232-extracting-texture-features">Section 2.3.2: Extracting texture features</h3>
<p>Using <code class="language-plaintext highlighter-rouge">101_ObjectCategories/emu/image_0001.jpg</code> as in the input image <code class="language-plaintext highlighter-rouge">im</code> and <code class="language-plaintext highlighter-rouge">Annotations/emu/annotation_0001.mat</code> as the annotation mask <code class="language-plaintext highlighter-rouge">mask</code>, we use the <code class="language-plaintext highlighter-rouge">extract_texture_features</code> function and print out the <code class="language-plaintext highlighter-rouge">f</code> vector and the <code class="language-plaintext highlighter-rouge">fnames</code> list.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>
<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">f</span><span class="p">,</span><span class="n">fnames</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'feature vector'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'feature names'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature vector
[9.44795021e-03 8.91621988e-03 8.49414681e-03 8.26354227e-03
 6.40602380e-04 3.13705857e-04 1.51332668e-04 1.57924464e-04
 2.60085612e+00 2.75670895e+00 2.96004591e+00 3.09156989e+00
 1.20573130e-01 8.59555132e-02 4.33562527e-02 5.85714661e-02
 1.56044800e+01 1.74694492e+01 2.01266035e+01 2.17261141e+01
 1.57594074e+00 1.06371099e+00 5.02286894e-01 4.12576946e-01
 3.72965154e-01 3.55317937e-01 3.37690195e-01 3.26456920e-01
 1.91489099e-02 1.13961311e-02 7.42917505e-03 8.08769450e-03
 9.71457997e-02 9.44111478e-02 9.21600423e-02 9.08999193e-02
 3.26248410e-03 1.65983452e-03 8.20617638e-04 8.64257319e-04
 6.11324265e-01 5.59225027e-01 4.79792054e-01 4.29846997e-01
 4.12875202e-02 2.94518620e-02 1.22013521e-02 1.04584654e-02]
feature names
['GLCM_ASM_d1_mean', 'GLCM_ASM_d2_mean', 'GLCM_ASM_d3_mean', 'GLCM_ASM_d4_mean', 'GLCM_ASM_d1_std', 'GLCM_ASM_d2_std', 'GLCM_ASM_d3_std', 'GLCM_ASM_d4_std', 'GLCM_dissimilarity_d1_mean', 'GLCM_dissimilarity_d2_mean', 'GLCM_dissimilarity_d3_mean', 'GLCM_dissimilarity_d4_mean', 'GLCM_dissimilarity_d1_std', 'GLCM_dissimilarity_d2_std', 'GLCM_dissimilarity_d3_std', 'GLCM_dissimilarity_d4_std', 'GLCM_contrast_d1_mean', 'GLCM_contrast_d2_mean', 'GLCM_contrast_d3_mean', 'GLCM_contrast_d4_mean', 'GLCM_contrast_d1_std', 'GLCM_contrast_d2_std', 'GLCM_contrast_d3_std', 'GLCM_contrast_d4_std', 'GLCM_homogeneity_d1_mean', 'GLCM_homogeneity_d2_mean', 'GLCM_homogeneity_d3_mean', 'GLCM_homogeneity_d4_mean', 'GLCM_homogeneity_d1_std', 'GLCM_homogeneity_d2_std', 'GLCM_homogeneity_d3_std', 'GLCM_homogeneity_d4_std', 'GLCM_energy_d1_mean', 'GLCM_energy_d2_mean', 'GLCM_energy_d3_mean', 'GLCM_energy_d4_mean', 'GLCM_energy_d1_std', 'GLCM_energy_d2_std', 'GLCM_energy_d3_std', 'GLCM_energy_d4_std', 'GLCM_correlation_d1_mean', 'GLCM_correlation_d2_mean', 'GLCM_correlation_d3_mean', 'GLCM_correlation_d4_mean', 'GLCM_correlation_d1_std', 'GLCM_correlation_d2_std', 'GLCM_correlation_d3_std', 'GLCM_correlation_d4_std']
</code></pre></div></div>

<h2 id="section-3-setting-up-a-feature-matrix-and-label-vector">Section 3: Setting up a Feature Matrix and Label Vector</h2>
<p>Now that we have defined functions that compute several different categories of features from an image object, we need to aggregate those features into a feature matrix.  This feature matrix will be  $N\times M$ where $N$ is the total number of images that we use as input and $M$ is the total number of features that we extract from each of the $N$ images. If we use all features from above we have a total of 97 features for each image (97 = 15 RGB features + 15 HSV features + 19 region features + 48 texture features).  This feature matrix is used as input to the classification algorithm to describe the image objects.</p>

<p>The classification algorithm, however, also needs to be told what the label of each image is so that it can learn to discriminate the different objects.  The label vector will be an $N\times 1$ vector.  Note that the number of rows $N$ in the feature matrix must correspond to the length $N$ of the label vector and there must be a one-to-one correspondence, i.e., the first row of the feature matrix must correspond to the first element in the label vector.  This label vector provides the identity (label) of each image.  There are different means to define labels for machine learning algorithms.  This example will be specific to the <code class="language-plaintext highlighter-rouge">sklearn</code> package in python, but will be similar in flavor to necessary format for other frameworks.  We will learn a different formulation of the label vector for deep learning in Tutorial 3.</p>

<h3 id="section-31-setting-up-a-matrix-to-discriminate-between-flamingos-and-emus">Section 3.1: Setting up a matrix to discriminate between flamingos and emus</h3>
<p>In this part, we use what we learned from Section 1 above about looping over the directory structure of the CalTech101 dataset.  We will loop over multiple images, extract features, and build a feature matrix and label vector.  We write this code so that the user can specify the categories of interest as a list of strings.  Those strings are used to navigate into the directories of images from which to extract features.  Feature vectors <code class="language-plaintext highlighter-rouge">f_rgb</code>, <code class="language-plaintext highlighter-rouge">f_hsv</code>, <code class="language-plaintext highlighter-rouge">f_region</code>,  and <code class="language-plaintext highlighter-rouge">f_texture</code> are extracted from each image and stacked in an $N\times97$ feature matrix, where $N$ is the total number of images, and 97 is the feature vector dimensionality.  At the same time, we create a corresponding $N\times1$ label vector (actually a list in python).</p>

<p>While we loop over all images in the specified categories, we split the data into a training set consisting of 90% of the data and a test set consisting of the remaining 10%.  We call the two feature matrices <code class="language-plaintext highlighter-rouge">X_train</code> and <code class="language-plaintext highlighter-rouge">X_test</code> and the  two label vectors, <code class="language-plaintext highlighter-rouge">y_train</code> and <code class="language-plaintext highlighter-rouge">y_test</code>, consistent with common notation in machine learning.  In this case, the label vectors <code class="language-plaintext highlighter-rouge">y_train</code> and <code class="language-plaintext highlighter-rouge">y_test</code> are actually lists of the class strings (e.g., <code class="language-plaintext highlighter-rouge">'emu'</code>).</p>

<p>Here, as an example, we specify the <code class="language-plaintext highlighter-rouge">'emu'</code> and <code class="language-plaintext highlighter-rouge">'flamingo'</code> directories, compute <code class="language-plaintext highlighter-rouge">X_train</code>, <code class="language-plaintext highlighter-rouge">X_test</code>, <code class="language-plaintext highlighter-rouge">y_train</code>, and <code class="language-plaintext highlighter-rouge">y_test</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span> 

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images 
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-13-86e9b4686b2d&gt; in &lt;module&gt;
     21         mask[r,c] = 1 # define annotation mask
     22         f_rgb,fnames_rgb = extract_color_features_rgb(im,mask) # extract RGB features
---&gt; 23         f_hsv,fnames_hsv = extract_color_features_hsv(im,mask) # extract HSV features
     24         f_region,fnames_region = extract_region_features(mask.astype(int)) # extract region features
     25         f_texture,fnames_texture = extract_texture_features(im,mask) # extract texture features


NameError: name 'extract_color_features_hsv' is not defined
</code></pre></div></div>

<h2 id="-your-turn--4"><span style="color:Green"> Your turn: </span></h2>
<p>Explore the dimensionalities and values of <code class="language-plaintext highlighter-rouge">X_train</code>, <code class="language-plaintext highlighter-rouge">X_test</code>, <code class="language-plaintext highlighter-rouge">y_train</code>, and <code class="language-plaintext highlighter-rouge">y_test</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h3 id="section-32-normalizing-the-feature-matrices">Section 3.2: Normalizing the feature matrices</h3>
<p>Some of the features have a larger range than others.  We don’t want those features to have undue influence on the classification.  We will thus normalize the feature matrices to have range [0,1].  There will be two slightly different procedures for normalizing <code class="language-plaintext highlighter-rouge">X_train</code> and <code class="language-plaintext highlighter-rouge">X_test</code>.</p>

<p>To normalize <code class="language-plaintext highlighter-rouge">X_train</code>, from each column we subtract the minimum of the column and divide by the maximum of the column. Additionally, we save the maximum values for each column in a $1\times97$ vector <code class="language-plaintext highlighter-rouge">mx</code> and the minimum values for each column in a $1\times97$ vector <code class="language-plaintext highlighter-rouge">mn</code>.</p>

<p>To normalize <code class="language-plaintext highlighter-rouge">X_test</code>, from each column we subtract the corresponding minimum from <code class="language-plaintext highlighter-rouge">mn</code> and divide by the corresponding maximum from <code class="language-plaintext highlighter-rouge">mx</code>.  This procedure treats the test data exactly the same as the training data.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">normalize_feature_columns</span><span class="p">(</span><span class="o">*</span><span class="n">argv</span><span class="p">):</span>
  
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">amin</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># minimum of feature (along columns)
</span>        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">),</span><span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mn</span><span class="p">))</span> <span class="c1"># zero minimum
</span>        <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">amax</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">mx</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">X</span><span class="p">[:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="n">f</span><span class="p">]</span><span class="o">/</span><span class="n">mx</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">),</span><span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mn</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">mx</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">X</span><span class="p">[:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="n">f</span><span class="p">]</span><span class="o">/</span><span class="n">mx</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">X</span>
</code></pre></div></div>

<h2 id="-your-turn--5"><span style="color:Green"> Your turn: </span></h2>
<p>For the same <code class="language-plaintext highlighter-rouge">X_train</code>, <code class="language-plaintext highlighter-rouge">X_test</code> as in Section 3.1, compute the normalized matrices <code class="language-plaintext highlighter-rouge">Xn_train</code>, <code class="language-plaintext highlighter-rouge">Xn_test</code>.  Explore the dimensionalities and values of <code class="language-plaintext highlighter-rouge">Xn_train</code> and <code class="language-plaintext highlighter-rouge">Xn_test</code> and compare to what you found above for <code class="language-plaintext highlighter-rouge">X_train</code> and <code class="language-plaintext highlighter-rouge">X_test</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<h2 id="section-4-classification">Section 4: Classification</h2>
<p>In this section we will use the support vector machine (SVM) classifier from <code class="language-plaintext highlighter-rouge">sklearn</code> as an example for how you can use the training data in <code class="language-plaintext highlighter-rouge">X_train</code> and <code class="language-plaintext highlighter-rouge">y_train</code> to train a classifier.  We we also use other supporting functions from <code class="language-plaintext highlighter-rouge">sklearn</code> to assess the performance of the SVM on the test data <code class="language-plaintext highlighter-rouge">X_test</code>.  The basic setup of the training and testing process for the SVM will be easily transferred to application of other common classifiers available in <code class="language-plaintext highlighter-rouge">sklearn</code>.</p>

<p>We will also explore modifications to the training process to explore some of the discriminative capabilities of the features we have extracted.  Finally, you will explore other standard classifiers available in <code class="language-plaintext highlighter-rouge">sklearn</code>.</p>

<h3 id="section-41-training-the-svm-classifier">Section 4.1: Training the SVM Classifier</h3>
<p>The commands here assume that we will be training a binary (two-class) classifier <code class="language-plaintext highlighter-rouge">svm.SVC</code>.  We first declare the SVM which is the step where we can configure various parameters of the SVM.  Next, we fit the SVM to the data.  You will notice that the fitting routine prints out a bunch of information about the classifier that was trained. That information gives us some idea about the different configuration parameters available in the SVM classifier.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="section-42-testing-the-svm-classifier">Section 4.2: Testing the SVM Classifier</h3>
<p>Now that we have trained the classifier by showing it the training data, we will test your classifier by predicting the labels for the test data.  We call the predicted labels <code class="language-plaintext highlighter-rouge">y_test_hat</code> where the <code class="language-plaintext highlighter-rouge">_hat</code> is in nod to the typical mathematical notation for an estimate.  Now that we have the predicted class labels <code class="language-plaintext highlighter-rouge">y_test_hat</code>, we compare them to the known class labels in <code class="language-plaintext highlighter-rouge">y_test</code>.  Here, we use two metrics to help us interpret the performance: the confusion matrix and the accuracy.  There are many other metrics available, see the documentation for <code class="language-plaintext highlighter-rouge">sklearn</code> at  https://scikit-learn.org/stable/user_guide.html.</p>

<p>The confusion matrix is a matrix of $L\times L$ where $L$ is the number of classes.  The $(i,j)$-th entry is a count of the number of times an actual class $i$ is predicted to be class $j$.  Thus, a perfect prediction will have a diagonal confusion matrix.  We also send in the list of category names to specify the order in which the classes appear in the confusion matrix.</p>

<p>We compute the overall classification accuracy from the confusion matrix by summing the diagonal of <code class="language-plaintext highlighter-rouge">C</code> (the number of correct classifications) by the total of <code class="language-plaintext highlighter-rouge">C</code> (the total number of training samples)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">,</span><span class="n">categories</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="-your-turn--6"><span style="color:Green"> Your turn: </span></h2>
<p>What does this confusion matrix and accuracy tell you about the performance of the SVM classifier?</p>

<h3 id="section-43-training-a-multi-class-classifier">Section 4.3 Training a multi-class classifier</h3>
<p>We can use the same <code class="language-plaintext highlighter-rouge">svm.SVC</code> classifier for a multi-class (more than two classes) classification problem.  Many, but not all classifiers can be applied to binary and multi-class problems.</p>

<h2 id="-your-turn--7"><span style="color:Green"> Your turn: </span></h2>
<p>Use what you learned above to create a three-class classifier using input from the CalTech101 dataset.  The basic two-class code is copied into the cell below for ease of editing.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span> 

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images 
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
            
<span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>

<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">,</span><span class="n">categories</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="section-44-exploring-discriminative-capabilities-of-different-features">Section 4.4 Exploring discriminative capabilities of different features</h3>
<p>We can train an SVM using only a subset of the features that we have defined.  This is essentially an exploration of the discriminatory potential of different individual features or sets of features via ablation.  In the code below, we re-compute the feature matrices and label vectors for the <code class="language-plaintext highlighter-rouge">'emu'</code> versus <code class="language-plaintext highlighter-rouge">'flamingo'</code> problem.  Since we will be using subsets of features, we extract all features here and will use slicing to send a subset of features to the SVM classifier.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span> 

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images 
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
            
<span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">30</span><span class="p">],</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">30</span><span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Color features only:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">[:,</span><span class="mi">30</span><span class="p">:</span><span class="mi">49</span><span class="p">],</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">[:,</span><span class="mi">30</span><span class="p">:</span><span class="mi">49</span><span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Region features only:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">[:,</span><span class="mi">49</span><span class="p">:],</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">[:,</span><span class="mi">49</span><span class="p">:])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Texture features only:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<h2 id="-your-turn--8"><span style="color:Green"> Your turn: </span></h2>
<p>Choose two or more categories from the CalTech101 dataset that you think might be more or less amenable to discrimination using certain feature subsets.  Using those categories, explore the discriminative capabilities of different feature subsets.  The basic code for using color features only for the <code class="language-plaintext highlighter-rouge">'emu'</code> versus <code class="language-plaintext highlighter-rouge">'flamingo'</code> classification problem is copied into the cell below for ease of editing.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span> 

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images 
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
            
<span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">30</span><span class="p">],</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">30</span><span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Color features only:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<h3 id="section-45-other-classifiers">Section 4.5 Other Classifiers</h3>
<p>There are many other classifiers available in the <code class="language-plaintext highlighter-rouge">sklearn</code> package, see https://scikit-learn.org/stable/user_guide.html for documentation.</p>

<h2 id="-your-turn--9"><span style="color:Green"> Your turn: </span></h2>
<p>Explore the capabilities of other classifiers.  If you don’t know where to start, some commonly referenced classifiers in the literature are</p>
<ul>
  <li>Linear Discriminant Analysis (LDA) available in <code class="language-plaintext highlighter-rouge">sklearn.discriminant_analysis</code> (Do a <code class="language-plaintext highlighter-rouge">from sklearn import discriminant_analysis</code> and then use <code class="language-plaintext highlighter-rouge">discriminant_analysis.LinearDiscriminantAnalysis</code>)</li>
  <li>k-Nearest Neighbors (KNN) available in <code class="language-plaintext highlighter-rouge">sklearn.neighbors</code> (Do a <code class="language-plaintext highlighter-rouge">from sklearn import neighbors</code> and then use <code class="language-plaintext highlighter-rouge">neighbors.KNeighborsClassifier</code>)</li>
  <li>Random Forest available in <code class="language-plaintext highlighter-rouge">sklearn.ensemble</code> (Do a <code class="language-plaintext highlighter-rouge">from sklearn import ensemble</code> and then use <code class="language-plaintext highlighter-rouge">ensemble.RandomForestClassifier</code></li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

        
      </section>

      <footer class="page__meta">
        
        


        
      </footer>

      

      

    </div>

    
  </article>

  
  
</div>
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form onsubmit="return googleCustomSearchExecute();" id="cse-search-box-form-id">
    <input type="search" id="cse-search-input-box-id" aria-placeholder="Enter your search term..." class="search-input" tabindex="-1" placeholder="Enter your search term..." />
    </form>
    <div id="results" class="results">
        <gcse:searchresults-only></gcse:searchresults-only>
    </div></div>

      </div>
    
    
    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    
    
      <li><a href="https://twitter.com/isugif"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
    
    
    
      <li><a href="https://github.com/https://github.com/isugenomics"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Geospatial Workbook</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.13/js/all.js"></script>


<script>
  (function () {
    var cx = '009853197685285203469:nsvri1pa88d';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();

  function googleCustomSearchExecute() {
    var input = document.getElementById('cse-search-input-box-id');
    var element = google.search.cse.element.getElement('searchresults-only0');
    if (input.value == '') {
      element.clearAllResults();
    } else {
      element.execute(input.value);
    }
    return false;
  }

  
</script>




<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" defer
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>




  </body>
</html>
