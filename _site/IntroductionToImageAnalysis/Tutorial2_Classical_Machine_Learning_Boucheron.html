<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.11.2 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Classical Machine Learning Fundamentals - Geospatial Workbook</title>
<meta name="description" content="Tutorial on Informatics for Geospatial Information">


  <meta name="author" content="Laura Boucheron">


<meta property="og:type" content="website">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Geospatial Workbook">
<meta property="og:title" content="Classical Machine Learning Fundamentals">
<meta property="og:url" content="http://localhost:4000/IntroductionToImageAnalysis/Tutorial2_Classical_Machine_Learning_Boucheron.html">




  <meta property="og:image" content="http://localhost:4000/assets/images/margaret-weir-GZyjbLNOaFg-unsplash_dark.jpg">



  <meta name="twitter:site" content="@isugif">
  <meta name="twitter:title" content="Classical Machine Learning Fundamentals">
  <meta name="twitter:description" content="Tutorial on Informatics for Geospatial Information">
  <meta name="twitter:url" content="http://localhost:4000/IntroductionToImageAnalysis/Tutorial2_Classical_Machine_Learning_Boucheron.html">

  
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="http://localhost:4000/assets/images/margaret-weir-GZyjbLNOaFg-unsplash_dark.jpg">
  

  
    <meta name="twitter:creator" content="@someone">
  







  

  


<link rel="canonical" href="http://localhost:4000/IntroductionToImageAnalysis/Tutorial2_Classical_Machine_Learning_Boucheron.html">







  <script type="application/ld+json">
    {
      "@context": "http://schema.org",
      "@type": "Person",
      "name": "",
      "url": "http://localhost:4000",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Geospatial Workbook Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-E6BZVYF8ZY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-E6BZVYF8ZY');
</script>

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="/">Geospatial Workbook</a>
        <ul class="visible-links">
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/about.html" >About</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/list.html" >Index</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/glossary.html" >Glossary</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/people.html" >People</a>
            </li>
          
            
            <li class="masthead__menu-item">
              <a href="http://localhost:4000/contributing.html" >Contribute</a>
            </li>
          
        </ul>
        
        <button class="search__toggle" type="button">
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle Menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
  











<div class="page__hero--overlay"
  style="background-color: 444444; background-image: url('/assets/images/margaret-weir-GZyjbLNOaFg-unsplash_dark.jpg');"
>
  
    <div class="wrapper">
      <h1 id="page-title" class="page__title" itemprop="headline">
        
          Classical Machine Learning Fundamentals

        
      </h1>
      
      
      
    </div>
  
  
</div>





<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/people/LauraBoucheron.jpg" alt="Laura Boucheron" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Laura Boucheron</h3>
    
    
      <p class="author__bio" itemprop="description">
        Laura E. Boucheron received the B.S. and M.S. degrees in electrical engineering from New Mexico State University, Las Cruces, in 2001 and 2003, respectively, and the Ph.D. degree in electrical and computer engineering from the University of California, Santa Barbara, in 2008. She has intern and graduate research experience at both Sandia National Laboratories and Los Alamos National Laboratory and postdoctoral and research faculty experience in the Klipsch School of Electrical and Computer Engineering at New Mexico State University. She is currently an Associate Professor in the Klipsch School. Her teaching interests include signals & systems, digital signal processing, digital image processing, and pattern recognition and machine learning. Her research interests include image analysis, feature extraction, pattern recognition and machine learning, temporal image analysis, interdisciplinary research, solar image analysis, and biomedical image analysis.
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      

      
        <li>
          <a href="mailto:mailto:someone@iastate.edu">
            <meta itemprop="email" content="mailto:someone@iastate.edu" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email
          </a>
        </li>
      

      

      
        <li>
          <a href="https://twitter.com/someone" itemprop="sameAs">
            <i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

<!-- Create a 2nd author for tutorials -->



<div itemscope itemtype="http://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name"></h3>
    
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="Classical Machine Learning Fundamentals">
    
    
    

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        
        <h1 id="tutorial-2-classical-machine-learning-fundamentals">Tutorial 2: Classical Machine Learning Fundamentals</h1>

<h2 id="laura-e-boucheron-electrical--computer-engineering-nmsu">Laura E. Boucheron, Electrical &amp; Computer Engineering, NMSU</h2>

<h3 id="october-2020">October 2020</h3>

<blockquote>
  <p>Copyright (C) 2020  Laura E. Boucheron</p>

  <p>This information is free; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.</p>

  <p>This work is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p>

  <p>You should have received a copy of the GNU General Public License along with this work in a file <code class="language-plaintext highlighter-rouge">COPYING.TXT</code>; if not, If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>
</blockquote>

<h2 id="overview">Overview</h2>
<p>In this tutorial, we present a brief overview of classical machine learning concepts as applicable to image classification applications.  Completion of this tutorial should give participants the basic background and terminology necessary for an understanding of the basics of classical machine learning as applied to image classification.  In this tutorial, we will develop a classical machine learning algorithm capable of discriminating between objects present in an image.</p>

<p>This tutorial contains 5 sections:</p>

<ul>
  <li><strong>Section 0: Preliminaries</strong>: some notes on using this notebook, how to download the image dataset that we will use for this tutorial, and import commands for the libraries necessary for this tutorial</li>
  <li><strong>Section 1: Working with the CalTech101 Dataest</strong>: how to traverse and use the directory structure and files provided in the CalTech101 Dataset</li>
  <li><strong>Section 2: Feature Extraction</strong>: examples of extraction of different feature categories from images, including color, region, and texture features
    <ul>
      <li><strong>Section 2.1: Color Features</strong>: statistics of the color within an image object</li>
      <li><strong>Section 2.2: Region Features</strong>: measures of the size and shape of the image object</li>
      <li><strong>Section 2.3: Texture Features</strong>: measures of the distribution of intensities within the image object</li>
    </ul>
  </li>
  <li><strong>Section 3: Setting up a Feature Matrix and Label Vector</strong>: aggregating features into a feature matrix in the format expected by machine learning algorithms along with definition of a label vector</li>
  <li><strong>Section 4: Classification</strong>: examples of common classification methods, including training and testing on the CalTech101 dataset</li>
</ul>

<p>There are subsections with the heading “<strong><span style="color:Green"> Your turn: </span></strong>” throughout this tutorial in which you will be asked to apply what you have learned.</p>

<h1 id="section-0-preliminaries">Section 0: Preliminaries</h1>
<h2 id="section-01-a-note-on-jupyter-notebooks">Section 0.1: A Note on Jupyter Notebooks</h2>

<p>There are two main types of cells in this notebook: code and markdown (text).  You can add a new cell with the plus sign in the menu bar above and you can change the type of cell with the dropdown menu in the menu bar above.  As you complete this tutorial, you may wish to add additional code cells to try out your own code and markdown cells to add your own comments or notes.</p>

<p>A jupyter notebook with code and markdown (text) sections is provided for your convenience.</p>

<ul>
  <li><a href="https://geospatial.101workbook.org/tutorials/Tutorial2_Classical_Machine_Learning_Boucheron.ipynb">Tutorial2_Classical_Machine_Learning_Boucheron.ipynb</a></li>
</ul>

<p>See <a href="intro-to-jupyterhub.md">Introduction to JupyterHub</a> for a review on how to use Jupyter notebooks.</p>

<!--

Markdown cells can be augmented with a number of text formatting features, including
  - bulleted
  - lists

embedded $\LaTeX$, monotype specification of `code syntax`, **bold font**, and *italic font*.  There are many other features of markdown cells--see the jupyter documentation for more information.

You can edit a cell by double clicking on it.  If you double click on this cell, you can see how to implement the various formatting referenced above.  Code cells can be run and markdown cells can be formatted using Shift+Enter or by selecting the Run button in the toolbar above.

Once you have completed (all or part) of this notebook, you can share your results with colleagues by sending them the `.ipynb` file.  Your colleagues can then open the file and will see your markdown and code cells as well as any results that were printed or displayed at the time you saved the notebook.  If you prefer to send a notebook without results displayed (like this notebook appeared when you downloaded it), you can select ("Restart & Clear Output") from the Kernel menu above.  You can also export this notebook in a non-executable form, e.g., `.pdf` through the File, Save As menu.

-->

<h2 id="section-02-downloading-images">Section 0.2 Downloading Images</h2>

<p>In this tutorial, we will use the CalTech101 dataset, which is a standard dataset used for image classification. Please read through the description of the dataset.</p>

<ul>
  <li><a href="http://www.vision.caltech.edu/Image_Datasets/Caltech101/">http://www.vision.caltech.edu/Image_Datasets/Caltech101/</a></li>
</ul>

<p>You will need the dataset of images and the annoations</p>

<ul>
  <li>101_ObjectCategories.tar.gz (126 MB)</li>
  <li>Annotations.tar (13 MB)</li>
</ul>

<p>Which will allow us to focus our feature extraction on only the objects in the images.</p>

<p>Extract the image dataset and the annotations in your working directory.  The images will extract to a <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code> directory, under which there are 102 directories named according to the object contained in the image (e.g., <code class="language-plaintext highlighter-rouge">accordion/</code> or <code class="language-plaintext highlighter-rouge">pizza/</code>), under which are files with file format <code class="language-plaintext highlighter-rouge">image_XXXX.jpg</code>, where <code class="language-plaintext highlighter-rouge">XXXX</code> is a four digit number. After extracing the files you should be left with a folder structure similar to:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>101_ObjectCategories/
  |_ Faces/
  |_ Faces_easy/
  |_ Leopards/
  |_ Motorbikes/
  .... several more folders containing images
</code></pre></div></div>

<p>Cleanup by removing or archiving the <code class="language-plaintext highlighter-rouge">BACKGROUND_Google/</code> folder.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>archive
<span class="nb">mv </span>101_ObjectCategories/BACKGROUND_Google archive/.
</code></pre></div></div>

<p>The annotations will extract to an <code class="language-plaintext highlighter-rouge">Annotations/</code> directory, underneath which there are 101 directories named the same categories (for the most part) as the <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code> categories, under which  are files <code class="language-plaintext highlighter-rouge">annotation_XXXX.mat</code>, where <code class="language-plaintext highlighter-rouge">XXXX</code> is a four digit number.  There are also 5 other files in the <code class="language-plaintext highlighter-rouge">Annotations/</code> directory.  In order to make subsequent code run more easily:</p>

<ul>
  <li>Within <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code>:
    <ul>
      <li>Delete directory <code class="language-plaintext highlighter-rouge">BACKGROUND_Google/</code></li>
    </ul>
  </li>
  <li>Within <code class="language-plaintext highlighter-rouge">Annotations/</code>:
    <ul>
      <li>Delete <code class="language-plaintext highlighter-rouge">*.mat</code></li>
      <li>Delete <code class="language-plaintext highlighter-rouge">README*</code></li>
      <li>Move (rename) directory <code class="language-plaintext highlighter-rouge">Airplanes_Side_2/</code> to <code class="language-plaintext highlighter-rouge">airplanes/</code></li>
      <li>Move (rename) directory <code class="language-plaintext highlighter-rouge">Faces_2/</code> to <code class="language-plaintext highlighter-rouge">Faces/</code></li>
      <li>Move (rename) directory <code class="language-plaintext highlighter-rouge">Faces_3/</code> to <code class="language-plaintext highlighter-rouge">Faces_easy/</code></li>
      <li>Move (rename) directory <code class="language-plaintext highlighter-rouge">Motorbikes_16/</code> to <code class="language-plaintext highlighter-rouge">Motorbikes/</code></li>
    </ul>
  </li>
</ul>

<p>From commandline, you can cleanup by running:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mv </span>Annotations/<span class="k">*</span>.mat archive/.
<span class="nb">mv </span>Annotations/README<span class="k">*</span> archive/.
<span class="nb">mv </span>Annotations/Airplanes_Side_2 Annotations/airplanes
<span class="nb">mv </span>Annotations/Faces_2 Annotations/Faces
<span class="nb">mv </span>Annotations/Faces_3 Annotations/Faces_easy
<span class="nb">mv </span>Annotations/Motorbikes_16 Annotations/Motorbikes
</code></pre></div></div>

<h2 id="section-03a-import-necessary-libraries-for-users-using-a-local-machine">Section 0.3a Import Necessary Libraries (For users using a local machine)</h2>
<p>Here, at the top of the code, we import all the libraries necessary for this tutorial.  We will introduce the functionality of any new libraries throughout the tutorial, but include all import statements here as standard coding practice.  We include a brief comment after each library here to indicate its main purpose within this tutorial.</p>

<p>It would be best to run this next cell before the workshop starts to make sure you have all the necessary packages installed on your machine.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span> <span class="c1"># visualization
</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span> <span class="c1"># mathematical and scientific functions
</span><span class="kn">import</span> <span class="nn">os</span> <span class="c1"># interaction with OS for file manipulation
</span><span class="kn">import</span> <span class="nn">glob</span> <span class="c1"># a nice unix-style interface for path and file manipulation
</span><span class="kn">import</span> <span class="nn">imageio</span> <span class="c1"># image I/O
</span><span class="kn">import</span> <span class="nn">skimage.measure</span> <span class="c1"># measure region properties
</span><span class="kn">import</span> <span class="nn">skimage.feature</span> <span class="c1"># measure region properties
</span><span class="kn">import</span> <span class="nn">scipy.io</span> <span class="k">as</span> <span class="n">spio</span> <span class="c1"># ability to load Matlab .mat files
</span><span class="kn">import</span> <span class="nn">sklearn</span> <span class="c1"># common classifiers
</span><span class="kn">import</span> <span class="nn">sklearn.metrics</span> <span class="c1"># classification metrics
</span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">svm</span> <span class="c1"># the support vector machine classifier
</span>
<span class="c1"># format matplotlib options
</span><span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="n">plt</span><span class="p">.</span><span class="n">rcParams</span><span class="p">.</span><span class="n">update</span><span class="p">({</span><span class="s">'font.size'</span><span class="p">:</span> <span class="mi">20</span><span class="p">})</span>
</code></pre></div></div>

<h2 id="section-03b-build-the-conda-environment-for-users-using-the-ars-hpc-ceres-with-jupyterlab">Section 0.3b Build the Conda Environment (For users using the ARS HPC Ceres with JupyterLab)</h2>
<p>Open a terminal from inside JupyterLab (File &gt; New &gt; Terminal) and type the following commands</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source activate
conda create --name NMSU-AI-Workshop_image-processing python=3.7 numpy matplotlib imageio scikit-image ipykernel -y
</code></pre></div></div>
<p>It may take 5 minutes to build the Conda environment.</p>

<p>When the environment finishes building, select this environment as your kernel in your Jupyter Notebook (click top right corner where you see Python 3, select your new kernel from the dropdown menu, click select)</p>

<p>You will want to do this BEFORE the workshop starts.</p>

<h1 id="section-1-working-with-the-caltech101-dataset">Section 1: Working with the CalTech101 Dataset</h1>
<h2 id="section-11-exploring-the-images">Section 1.1: Exploring the Images</h2>
<p>In the previous tutorial, we were working with only two images.  There are more than 8000 images in 101 different directories in the CalTech101 dataset.  We thus need to develop ways to efficiently loop over larger image datasets and access the images without hard coding the image filenames.</p>

<p>Here, we will use the <code class="language-plaintext highlighter-rouge">glob</code> library to store directory names and filenames in a list.  You can store the directory names of the CalTech101 dataset in a list with <code class="language-plaintext highlighter-rouge">categories=sorted(glob.glob('101_ObjectCategories/*')</code>.  This list now gives you a means to loop over the 101 different categories of objects in that <code class="language-plaintext highlighter-rouge">categories[k]</code> is the <code class="language-plaintext highlighter-rouge">k</code>-th category name as a string (including the string <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code> prepended to the category name).  A few other notes:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">glob.glob</code> returns an unordered list.  We wrap a <code class="language-plaintext highlighter-rouge">sorted</code> around the <code class="language-plaintext highlighter-rouge">glob.glob</code> command to return the directories or filenames in the usual alphabetical order</li>
  <li><code class="language-plaintext highlighter-rouge">glob.glob</code> returns a list with the full pathname (from where you searched) prepended.  In this case, since we search from the directory just under <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code>, the string <code class="language-plaintext highlighter-rouge">101_ObjectCategories/</code> will be prepended to each of the 101 object categories.  If we had searched using a more complete path, e.g., <code class="language-plaintext highlighter-rouge">categories=sorted(glob.glob('/home/user/tutorials/101_ObjectCategories/*')</code>, the full specified path would be prepended to each of the categories.  The full pathname is very helpful if you need to access something within that path since you don’t need to manually preprend the full path.</li>
  <li><code class="language-plaintext highlighter-rouge">os.path.basename</code> will strip off only the base directory or filename from the full path if you don’t want the full path.</li>
</ul>

<p>Using this list <code class="language-plaintext highlighter-rouge">categories</code>, we can read in the first image (<code class="language-plaintext highlighter-rouge">image_0001.jpg</code>) from each of the 101 categories and display that image in one location of an $11\times10$ subplot.  We can also title each of those locations of the subplot with the category name.  We note that this code is not robust in the sense that we are relying on the existence of a specific filename format under each of the directories in <code class="language-plaintext highlighter-rouge">101_ObjectCategories</code>.  We will work with more robust means to traverse the files that exist in each directory in later portions of this tutorial.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span><span class="o">=</span><span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/*'</span><span class="p">))</span>

<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">45</span><span class="p">))</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">category</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">categories</span><span class="p">):</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">category</span><span class="o">+</span><span class="s">'/image_0001.jpg'</span><span class="p">))</span>  <span class="c1"># category has full path
</span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">plt</span><span class="p">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="s">'gray'</span><span class="p">)</span> <span class="c1"># change colormap to be gray
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># access the k-th supblot in an 11x10 grid
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">basename</span><span class="p">(</span><span class="n">category</span><span class="p">))</span> <span class="c1"># strip off basename for title
</span></code></pre></div></div>

<p><img src="/IntroductionToImageAnalysis/images/Tutorial2_Classical_Machine_Learning_Boucheron_7_0.png" alt="png" /></p>

<h2 id="section-12-exploring-the-annotations">Section 1.2 Exploring the Annotations</h2>
<h3 id="section-121-plotting-the-annotations-as-a-boundary-over-the-image">Section 1.2.1 Plotting the annotations as a boundary over the image</h3>
<p>The annotations are stored in Matlab’s <code class="language-plaintext highlighter-rouge">.mat</code> format, which the <code class="language-plaintext highlighter-rouge">scipy.io</code> library in python can load.  Above, we have imported <code class="language-plaintext highlighter-rouge">scipy.io</code> as <code class="language-plaintext highlighter-rouge">spio</code>.  The image annotations can be read in with the <code class="language-plaintext highlighter-rouge">spio.loadmat</code> function, e.g., <code class="language-plaintext highlighter-rouge">ann=spio.loadmat('filename.mat')</code>.  The <code class="language-plaintext highlighter-rouge">spio.loadmat</code> function returns a dictionary with variable names as keys.  In the CalTech101 annotations, dictionary entry <code class="language-plaintext highlighter-rouge">ann['box_coord']</code> is a $1\times4$ vector of bounding box coordinates and <code class="language-plaintext highlighter-rouge">ann['obj_contour']</code> is a $2\times K$ vector of pixel locations which outline the contour of the object, where $K$ will be different for different annotations.</p>

<p>As an example, we read in <code class="language-plaintext highlighter-rouge">Annotations/emu/annotation_0001.mat</code> and display <code class="language-plaintext highlighter-rouge">box_coord</code> and <code class="language-plaintext highlighter-rouge">obj_contour</code>.  The object contour points <code class="language-plaintext highlighter-rouge">obj_contour</code> are (for reasons unbeknownst to us) offset by the upper left <code class="language-plaintext highlighter-rouge">box_coord</code> coordinates.</p>

<p>As a further example, we read in the corresponding image <code class="language-plaintext highlighter-rouge">101_ObjectCategories/emu/image_0001.jpg</code> and display it.  On top of that image, we plot the annotation outline with a basic plot command <code class="language-plaintext highlighter-rouge">plt.plot(ann['obj_contour'][0,:]+ann['box_coord'][0,2]-1,ann['obj_contour'][1,:]+ann['box_coord'][0,0]-1,'w')</code>.  A few notes:</p>
<ul>
  <li>We offset the contour points by the upper left corner of the bounding box.</li>
  <li>We need to offset all the points by -1 due to the difference in indexing in Matlab (starting at 1) and python (starting at 0).  Since the annotations were output in Matlab, the indexing is consistent with Matlab convention.</li>
  <li>We note that the annotations appear to be provided in standard Euclidean coordinates, i.e., assuming an x-axis (column), y-axis (row) ordering.</li>
  <li>We note that since we first displayed the image using <code class="language-plaintext highlighter-rouge">plt.imshow</code>, the axes for the figure are assumed to have the origin in the top left.  The <code class="language-plaintext highlighter-rouge">plt.plot</code> command will use the plotting coordinate conventions of x-axis, y-axis, but will follow the origin set up by the image visualization.</li>
  <li>All of the aforementioned observations were noted based on exploration of visualization of the annotations and hard-learned lessons regarding conventions in coordinate systems for images and image metadata.  Some insights were additionally gathered from the <code class="language-plaintext highlighter-rouge">show_annotation.m</code> file from http://www.vision.caltech.edu/Image_Datasets/Caltech101/show_annotation.m (the link appears to be currently broken, however).</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>

<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'box_coord'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">'obj_contour'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">])</span>

<span class="c1"># ann['box_coord'] appears to have the bounding box vertices specified as
# [row_min, row_max, col_min, col_max] or [y_min, y_max, x_min, x_max]
# ann['obj_contour'] appears to have the column indices (x-axis) in the zeroth row and the
# row indices (y-axis) in the first row
</span>
<span class="c1"># plot expects the x-axis first and the y-axis second (col first, row second)
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
         <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">'w'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Annotated Emu'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>box_coord
[[  7 247  72 293]]
obj_contour
[[ 16.57982456  14.46578947  11.50614035   9.39210526  18.27105263
   29.26403509  36.8745614   39.83421053  47.86754386  36.45175439
   31.37807018  43.21666667  77.46403509 104.52368421 127.77807018
  159.06578947 189.93070175 204.30614035 215.29912281 213.60789474
  163.29385965 141.30789474 123.12719298  92.68508772  74.92719298
   50.82719298  19.11666667   6.85526316   6.00964912  17.4254386
   17.4254386 ]
 [ 78.93070175  53.98508772  28.19385965  10.43596491   2.8254386
    5.3622807   13.81842105  25.23421053  34.95877193  35.38157895
   42.99210526  81.04473684 119.94298246 117.82894737 123.3254386
  141.08333333 168.98859649 196.47105263 229.87280702 240.02017544
  240.44298246 217.18859649 240.44298246 240.02017544 232.83245614
  223.10789474 193.51140351 163.49210526 113.60087719  78.50789474
   78.50789474]]
</code></pre></div></div>

<p><img src="/IntroductionToImageAnalysis/images/Tutorial2_Classical_Machine_Learning_Boucheron_9_1.png" alt="png" /></p>

<h3 id="section-122-some-common-coordinate-issues-that-may-be-encountered-with-annotations">Section 1.2.2 Some common coordinate issues that may be encountered with annotations</h3>
<p>We noted above that since we first displayed the image using <code class="language-plaintext highlighter-rouge">plt.imshow</code>, the axes for the figure are assumed to have the origin in the top left.  The <code class="language-plaintext highlighter-rouge">plt.plot</code> command will use the plotting coordinate conventions of x-axis, y-axis, but will follow the origin set up by the image visualization.  We further explore this issue by using the same plotting command <code class="language-plaintext highlighter-rouge">plt.plot(ann['obj_contour'][0,:]+ann['box_coord'][0,2]-1,ann['obj_contour'][1,:]+ann['box_coord'][0,0]-1,'r')</code> as above, but without first visualizing the image.  This means that the <code class="language-plaintext highlighter-rouge">plt.plot</code> command is expected to use the plotting coordinate conventions of x-axis, y-axis and have the origin in the bottom left.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
         <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Emu Annotation Alone'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'image'</span><span class="p">)</span> <span class="c1"># this just makes the aspect ratio consistent rather than "stretching" the image
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/IntroductionToImageAnalysis/images/Tutorial2_Classical_Machine_Learning_Boucheron_11_0.png" alt="png" /></p>

<h4 id="reversing-coordinates">Reversing coordinates</h4>
<p>A very common mistake in plotting (x,y) coordinates on top of images is accidentally reversing the order of the coordinates.  Given the rotated coordinate system used for images, this can cause a common “rotation” of expected results.  If we accidentally plotted the annotation in row, column order, we would achieve something like follows.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
         <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s">'w'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Annotated Emu'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/IntroductionToImageAnalysis/images/Tutorial2_Classical_Machine_Learning_Boucheron_13_0.png" alt="png" /></p>

<h3 id="section-123-computing-a-binary-object-mask-from-the-annotation-data">Section 1.2.3 Computing a binary object mask from the annotation data</h3>
<p>You can use the object contour outline to define a binary image image mask with <code class="language-plaintext highlighter-rouge">r,c = skimage.draw.polygon(ann['obj_contour'][1,:]+ann['box_coord'][0,0]-1,ann['obj_contour'][0,:]+ann['box_coord'][0,2]-1,(M,N)); A=np.zeros(M,N); A[r,c]=1;</code> (note that the object contour indices are swapped here versus the plot command used above due to the difference in coordinate systems of image versus plot) where <code class="language-plaintext highlighter-rouge">M</code>, <code class="language-plaintext highlighter-rouge">N</code> are the dimensions of the image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
         <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">I</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Original Emu Image'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s">'gray'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'Binary Emu Mask'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/IntroductionToImageAnalysis/images/Tutorial2_Classical_Machine_Learning_Boucheron_15_0.png" alt="png" /></p>

<h2 id="-your-turn-"><span style="color:Green"> Your turn: </span></h2>
<p>Using what you have learned about using lists to loop over categories, load the first annotation (<code class="language-plaintext highlighter-rouge">annotation_0001.mat</code>) from each of the 101 categories, use the corresponding <code class="language-plaintext highlighter-rouge">obj_contour</code> to define an object mask, and display that mask in one location of an $11\times10$  subplot.  Title each of those locations of the subplot with the category name.  You might find it handy to read in the image corresponding to the annotation in order to easily get the dimensions.  The visualizations from the previous part can be used here to spot-check the correctness of the annotations.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ann['box_coord'] appears to have the bounding box vertices specified
# as [row_min, col_min, row_max, col_max] or [y_min, x_min, y_max,
# x_max]
# ann['obj_contour'] appears to have the row indices (y-axis) in the
# zeroth row and the column indices (x-axis) in the first row
</span>
<span class="n">im_categories</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/*'</span><span class="p">))</span>
<span class="n">an_categories</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/*'</span><span class="p">))</span>

<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">45</span><span class="p">))</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">im_category</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">im_categories</span><span class="p">):</span>
    <span class="n">an_category</span> <span class="o">=</span> <span class="n">an_categories</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="c1"># category has full path
</span>    <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_category</span><span class="o">+</span><span class="s">'/annotation_0001.mat'</span><span class="p">)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_category</span><span class="o">+</span><span class="s">'/image_0001.jpg'</span><span class="p">)</span>
    <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span>\
                               <span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                               <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span>\
                               <span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">I</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">I</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># access the k-th supblot in an 11x10 grid
</span>    <span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="s">'gray'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">axis</span><span class="p">(</span><span class="s">'off'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">basename</span><span class="p">(</span><span class="n">im_category</span><span class="p">))</span> <span class="c1"># strip off basename for title
</span></code></pre></div></div>

<p><img src="/IntroductionToImageAnalysis/images/Tutorial2_Classical_Machine_Learning_Boucheron_17_1.png" alt="png" /></p>

<h2 id="section-2-feature-extraction">Section 2: Feature Extraction</h2>
<p>In this section we will define several functions designed to extract different categories of features from images.  These functions will span several common categories of features, but are by no means a comprehensive list.  These feature extraction methods are illustration of so-called “hand-designed” features.  These are features that are specifically implemented as features that are expected to be helpful for discriminating between different image categories.</p>

<h3 id="section-21-color-features">Section 2.1 Color Features</h3>
<p>In this section, we will extract a set of features designed to charaterize the colors present in an image.  We use the annotation mask as defined above to focus our attention on features only within the object of interest rather than features of the entire image.</p>

<h3 id="section-211-defining-color-statistics">Section 2.1.1 Defining color statistics</h3>
<p>Here we create a function <code class="language-plaintext highlighter-rouge">f,fnames=extract_color_features_rgb(im,mask)</code> with inputs <code class="language-plaintext highlighter-rouge">im</code>, the image from which to extract features, and the binary annotation mask, <code class="language-plaintext highlighter-rouge">mask</code>.  Outputs will be a length-15 feature vector <code class="language-plaintext highlighter-rouge">f</code> describing statistics of the colors within the image object and a length-15 list <code class="language-plaintext highlighter-rouge">fnames</code> with the feature names.  We extract statistics from the red, green, and blue channels of the image.  From each channel, we compute the mean, standard deviation, median, min, and max value of pixels <em>within the object mask</em>.  We order the features by channel first in the order given above and by statistic second in the order given above (i.e., the first and second features will be mean and standard deviation of the red channel).  We assign brief, descriptive strings for each feature and store those in <code class="language-plaintext highlighter-rouge">fnames</code> (e.g., <code class="language-plaintext highlighter-rouge">'R_mean'</code>, and <code class="language-plaintext highlighter-rouge">'R_std'</code> as names for the first two features).  Note that we also need to take care of the situation in which the image is a grayscale image, i.e., only one channel by using the <code class="language-plaintext highlighter-rouge">skimage.color.gray2rgb</code> function to convert to an RGB image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">gray2rgb</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">im</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">mean</span><span class="p">(),</span> <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">std</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]),</span> \
                     <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">min</span><span class="p">(),</span> <span class="n">R</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">max</span><span class="p">()])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">mean</span><span class="p">(),</span> <span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">std</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]),</span> \
                     <span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">min</span><span class="p">(),</span>  <span class="n">G</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">max</span><span class="p">()])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">mean</span><span class="p">(),</span> <span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">std</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]),</span> \
                     <span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">min</span><span class="p">(),</span>  <span class="n">B</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">max</span><span class="p">()])</span>

    <span class="n">fnames</span> <span class="o">=</span> <span class="p">(</span><span class="s">'R_mean'</span><span class="p">,</span><span class="s">'R_std'</span><span class="p">,</span><span class="s">'R_median'</span><span class="p">,</span><span class="s">'R_min'</span><span class="p">,</span><span class="s">'R_max'</span><span class="p">,</span>\
              <span class="s">'G_mean'</span><span class="p">,</span><span class="s">'G_std'</span><span class="p">,</span><span class="s">'G_median'</span><span class="p">,</span><span class="s">'G_min'</span><span class="p">,</span><span class="s">'G_max'</span><span class="p">,</span>\
              <span class="s">'B_mean'</span><span class="p">,</span><span class="s">'B_std'</span><span class="p">,</span><span class="s">'B_median'</span><span class="p">,</span><span class="s">'B_min'</span><span class="p">,</span><span class="s">'B_max'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">fnames</span>
</code></pre></div></div>

<h3 id="section-212-extracting-color-statistics">Section 2.1.2 Extracting color statistics</h3>
<p>Using <code class="language-plaintext highlighter-rouge">101_ObjectCategories/emu/image_0001.jpg</code> as the input image <code class="language-plaintext highlighter-rouge">im</code> and <code class="language-plaintext highlighter-rouge">Annotations/emu/annotation_0001.mat</code> as the annotation mask <code class="language-plaintext highlighter-rouge">mask</code>, we use the <code class="language-plaintext highlighter-rouge">extract_color_features_rgb</code> function and print out the <code class="language-plaintext highlighter-rouge">f</code> vector and the <code class="language-plaintext highlighter-rouge">fnames</code> list.  These features may not mean much to us as printed, but such a printed output can be used as a sanity check.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>
<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">f</span><span class="p">,</span><span class="n">fnames</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'feature vector'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'feature names'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature vector
[ 89.66263904  41.77544731  85.           3.         255.
  60.43520174  36.47920188  53.           0.         250.
  70.16239913  37.50792712  63.           0.         255.        ]
feature names
('R_mean', 'R_std', 'R_median', 'R_min', 'R_max', 'G_mean', 'G_std', 'G_median', 'G_min', 'G_max', 'B_mean', 'B_std', 'B_median', 'B_min', 'B_max')
</code></pre></div></div>

<h2 id="-your-turn--1"><span style="color:Green"> Your turn: </span></h2>
<p>Create a feature extraction function <code class="language-plaintext highlighter-rouge">f,fnames=extract_color_features_hsv(im,mask)</code> with inputs <code class="language-plaintext highlighter-rouge">im</code>, the image from which to extract features, and the binary annotation mask, <code class="language-plaintext highlighter-rouge">mask</code>.  Outputs will be a length-15 feature vector <code class="language-plaintext highlighter-rouge">f</code> describing statistics of the colors in HSV space within the image object and a length-15 list <code class="language-plaintext highlighter-rouge">fnames</code> with the feature names.  Extract statistics from the hue, saturation, and value channels of the image.  From each channel, compute the mean, standard deviation, median, min, and max value of pixels within the object mask.  In order to convert between the RGB and HSV color space, use the command <code class="language-plaintext highlighter-rouge">skimage.color.rgb2hsv</code>.  Order the features by channel first in the order given above and by statistic second in the order given above (i.e., the first and second features will be mean and standard deviation of the hue channel).  Assign brief, descriptive strings for each feature and store those in <code class="language-plaintext highlighter-rouge">fnames</code> (e.g., <code class="language-plaintext highlighter-rouge">'H_mean'</code>, and <code class="language-plaintext highlighter-rouge">'H_std'</code> as names for the first two features).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">gray2rgb</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">HSV</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">rgb2hsv</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">HSV</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">HSV</span><span class="p">[:,:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">HSV</span><span class="p">[:,:,</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">H</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">mean</span><span class="p">(),</span> <span class="n">H</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">std</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]),</span> \
                     <span class="n">H</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">min</span><span class="p">(),</span>  <span class="n">H</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">max</span><span class="p">()])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">S</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">mean</span><span class="p">(),</span> <span class="n">S</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">std</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]),</span> \
                     <span class="n">S</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">min</span><span class="p">(),</span>  <span class="n">S</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">max</span><span class="p">()])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">,[</span><span class="n">V</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">mean</span><span class="p">(),</span> <span class="n">V</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="n">std</span><span class="p">(),</span> <span class="n">np</span><span class="p">.</span><span class="n">median</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]),</span> \
                     <span class="n">V</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">min</span><span class="p">(),</span>  <span class="n">V</span><span class="p">[</span><span class="n">mask</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">].</span><span class="nb">max</span><span class="p">()])</span>

    <span class="n">fnames</span> <span class="o">=</span> <span class="p">(</span><span class="s">'H_mean'</span><span class="p">,</span><span class="s">'H_std'</span><span class="p">,</span><span class="s">'H_median'</span><span class="p">,</span><span class="s">'H_min'</span><span class="p">,</span><span class="s">'H_max'</span><span class="p">,</span>\
              <span class="s">'S_mean'</span><span class="p">,</span><span class="s">'S_std'</span><span class="p">,</span><span class="s">'S_median'</span><span class="p">,</span><span class="s">'S_min'</span><span class="p">,</span><span class="s">'S_max'</span><span class="p">,</span>\
              <span class="s">'V_mean'</span><span class="p">,</span><span class="s">'V_std'</span><span class="p">,</span><span class="s">'V_median'</span><span class="p">,</span><span class="s">'V_min'</span><span class="p">,</span><span class="s">'V_max'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">fnames</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>
<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">f</span><span class="p">,</span><span class="n">fnames</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'feature vector'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'feature names'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature vector
[0.93191605 0.07237925 0.94736842 0.         0.99666667 0.36125379
 0.11130164 0.34951456 0.01960784 1.         0.35243261 0.16304442
 0.33333333 0.01960784 1.        ]
feature names
('H_mean', 'H_std', 'H_median', 'H_min', 'H_max', 'S_mean', 'S_std', 'S_median', 'S_min', 'S_max', 'V_mean', 'V_std', 'V_median', 'V_min', 'V_max')
</code></pre></div></div>

<h3 id="section-22-region-features">Section 2.2 Region features</h3>
<p>In this section, we will extract a set of features designed to characterize the size and shape of an image object.  We use the annotation mask as defined above to define the object of interest.</p>

<h3 id="section-221-defining-region-features">Section 2.2.1: Defining region features</h3>
<p>We will use the <code class="language-plaintext highlighter-rouge">skimage.measure.regionprops</code> function to compute a list of region-based features in the <code class="language-plaintext highlighter-rouge">extract_region_features</code> function below.  We will not use all of the features available in <code class="language-plaintext highlighter-rouge">skimage.measure.regionprops</code> because some of those features may not be useul in our image classification situation.  For example, the centroid of the object or the orientation of the object may bias the classifier to translation or rotation variance.  In all subsequent discussion, the term “region” is used to denote the annotated region in an image.  The 19 features extracted below are measures of region characteristics of a region, including:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">'area'</code>: the number of pixels in the region</li>
  <li><code class="language-plaintext highlighter-rouge">'bbox_area'</code>: the number of pixels in the bounding box that contains the region</li>
  <li><code class="language-plaintext highlighter-rouge">'convex_area'</code>: the number of pixels in the convex hull of the region (think about “snapping a rubber band” around the region–that is the convex hull)</li>
  <li><code class="language-plaintext highlighter-rouge">'eccentricity'</code>: eccentricity of the ellipse with the same second order moments as the region</li>
  <li><code class="language-plaintext highlighter-rouge">'equivalent_diameter'</code>: the diameter of the circle with the same area as the region</li>
  <li><code class="language-plaintext highlighter-rouge">'euler_number'</code>: a measure of the “holy-ness” of the region</li>
  <li><code class="language-plaintext highlighter-rouge">'extent'</code>: ratio of area of the region to area of the bounding box</li>
  <li><code class="language-plaintext highlighter-rouge">'filled_area'</code>: the number of pixels in the region if the holes were filled</li>
  <li><code class="language-plaintext highlighter-rouge">'major_axis_length'</code>: the length of the major axis of the ellipse with the same second order moments as the region</li>
  <li><code class="language-plaintext highlighter-rouge">'minor_axis_length'</code>: the length of the minor axis of the ellipse with the same second order moments as the region</li>
  <li><code class="language-plaintext highlighter-rouge">'moments_hu'</code>: seven weighted moments (averages) of the region, designed to be invariant to rotation, scale, and translation of the region</li>
  <li><code class="language-plaintext highlighter-rouge">'perimeter'</code>: the length of the perimeter of the object (measured in number of pixels)</li>
  <li><code class="language-plaintext highlighter-rouge">'solidity'</code>: ratio of area of the region to convex area of the region</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_region_features_try1</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
    <span class="n">props</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">measure</span><span class="p">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">area</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bbox_area</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">convex_area</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">eccentricity</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">equivalent_diameter</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">euler_number</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">extent</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">filled_area</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">major_axis_length</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">minor_axis_length</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">moments_hu</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">perimeter</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">solidity</span><span class="p">])</span>

    <span class="n">fnames</span> <span class="o">=</span> <span class="p">(</span><span class="s">'area'</span><span class="p">,</span> <span class="s">'bbox_area'</span><span class="p">,</span> <span class="s">'convex_area'</span><span class="p">,</span> <span class="s">'eccentricity'</span><span class="p">,</span>\
              <span class="s">'equivalent_diameter'</span><span class="p">,</span> <span class="s">'euler_number'</span><span class="p">,</span> <span class="s">'extent'</span><span class="p">,</span> <span class="s">'filled_area'</span><span class="p">,</span>\
              <span class="s">'major_axis_length'</span><span class="p">,</span> <span class="s">'minor_axis_length'</span><span class="p">,</span> <span class="s">'moments_hu'</span><span class="p">,</span>\
              <span class="s">'perimeter'</span><span class="p">,</span> <span class="s">'solidity'</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">,</span><span class="n">fnames</span>
</code></pre></div></div>

<h3 id="section-222-extracting-region-features">Section 2.2.2: Extracting region features</h3>
<p>Using <code class="language-plaintext highlighter-rouge">101_ObjectCategories/emu/image_0001.jpg</code> as the input image <code class="language-plaintext highlighter-rouge">im</code> and <code class="language-plaintext highlighter-rouge">Annotations/emu/annotation_0001.mat</code> as the annotation mask <code class="language-plaintext highlighter-rouge">mask</code>, we use the <code class="language-plaintext highlighter-rouge">extract_region_features_try1</code> function and print out the <code class="language-plaintext highlighter-rouge">f</code> vector and the <code class="language-plaintext highlighter-rouge">fnames</code> list. Depending on your version of python, you may get a deprecation warning when running the following code.  That deprecation warning is related to the issue that you will explore in the next <strong><span style="color:Green"> Your turn: </span></strong> block.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>
<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">f</span><span class="p">,</span><span class="n">fnames</span> <span class="o">=</span> <span class="n">extract_region_features_try1</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s">'feature vector'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'feature names'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature vector
[22925 49742 28789 0.86209198262317 170.8479340321492 1
 0.46087813115676896 22925 270.70752758375147 137.18153400649817
 array([2.51094162e-01, 2.20473857e-02, 6.43740783e-03, 1.26777654e-03,
       2.54548085e-06, 1.25658455e-05, 2.57636709e-06])
 824.5655839020935 0.7963110910417173]
feature names
('area', 'bbox_area', 'convex_area', 'eccentricity', 'equivalent_diameter', 'euler_number', 'extent', 'filled_area', 'major_axis_length', 'minor_axis_length', 'moments_hu', 'perimeter', 'solidity')


/Users/jenchang/miniconda/envs/geo_env/lib/python3.7/site-packages/ipykernel_launcher.py:8: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify 'dtype=object' when creating the ndarray
</code></pre></div></div>

<h2 id="-your-turn--2"><span style="color:Green"> Your turn: </span></h2>
<p>We are designing functions that can extract a vector of features from image regions.  What issue do you note with the feature vector that is returned by <code class="language-plaintext highlighter-rouge">extract_region_features_try1</code>?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">whos</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Variable                       Type        Data/Info
----------------------------------------------------
A                              ndarray     334x290x3: 290580 elems, type `float64`, 2324640 bytes (2.216949462890625 Mb)
I                              Array       [[[135 142 135]\n  [145 1&lt;...&gt;7  90]\n  [ 50  65  88]]]
an_categories                  list        n=106
an_category                    str         Annotations/FeatureDetectionQuality.mat
ann                            dict        n=5
c                              ndarray     22925: 22925 elems, type `int64`, 183400 bytes (179.1015625 kb)
categories                     list        n=102
category                       str         101_ObjectCategories/yin_yang
extract_color_features_hsv     function    &lt;function extract_color_f&lt;...&gt;es_hsv at 0x7fdc2e1d44d0&gt;
extract_color_features_rgb     function    &lt;function extract_color_f&lt;...&gt;es_rgb at 0x7fdc2e1d47a0&gt;
extract_region_features_try1   function    &lt;function extract_region_&lt;...&gt;s_try1 at 0x7fdc2dc10050&gt;
f                              ndarray     13: 13 elems, type `object`, 104 bytes
fnames                         tuple       n=13
glob                           module      &lt;module 'glob' from '/Use&lt;...&gt;v/lib/python3.7/glob.py'&gt;
im                             ndarray     248x300x3: 223200 elems, type `uint8`, 223200 bytes (217.96875 kb)
im_categories                  list        n=102
im_category                    str         101_ObjectCategories/Leopards
imageio                        module      &lt;module 'imageio' from '/&lt;...&gt;ges/imageio/__init__.py'&gt;
k                              int         3
mask                           ndarray     248x300: 74400 elems, type `float64`, 595200 bytes (581.25 kb)
np                             module      &lt;module 'numpy' from '/Us&lt;...&gt;kages/numpy/__init__.py'&gt;
os                             module      &lt;module 'os' from '/Users&lt;...&gt;env/lib/python3.7/os.py'&gt;
plt                            module      &lt;module 'matplotlib.pyplo&lt;...&gt;es/matplotlib/pyplot.py'&gt;
r                              ndarray     22925: 22925 elems, type `int64`, 183400 bytes (179.1015625 kb)
skimage                        module      &lt;module 'skimage' from '/&lt;...&gt;ges/skimage/__init__.py'&gt;
sklearn                        module      &lt;module 'sklearn' from '/&lt;...&gt;ges/sklearn/__init__.py'&gt;
spio                           module      &lt;module 'scipy.io' from '&lt;...&gt;es/scipy/io/__init__.py'&gt;
svm                            module      &lt;module 'sklearn.svm' fro&lt;...&gt;sklearn/svm/__init__.py'&gt;
</code></pre></div></div>

<p>The feature vector is of type “object” indicating that it is not a simple feature vector.  The vector feature from the Hu moments have not been appended to the feature vector as individual elements.</p>

<h2 id="-your-turn--3"><span style="color:Green"> Your turn: </span></h2>
<p>Here is a modification to the region feature extraction code called simply <code class="language-plaintext highlighter-rouge">extract_region_features</code>.  Use this function to compare and contrast the output to the output from <code class="language-plaintext highlighter-rouge">extract_region_features_try1</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
    <span class="n">props</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">measure</span><span class="p">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">area</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">bbox_area</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">convex_area</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">eccentricity</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">equivalent_diameter</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">euler_number</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">extent</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">filled_area</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">major_axis_length</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">minor_axis_length</span><span class="p">,</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">moments_hu</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">moments_hu</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">moments_hu</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">moments_hu</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">moments_hu</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">moments_hu</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>\
                  <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">moments_hu</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">perimeter</span><span class="p">,</span> <span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">solidity</span><span class="p">])</span>

    <span class="n">fnames</span> <span class="o">=</span> <span class="p">(</span><span class="s">'area'</span><span class="p">,</span> <span class="s">'bbox_area'</span><span class="p">,</span> <span class="s">'convex_area'</span><span class="p">,</span> <span class="s">'eccentricity'</span><span class="p">,</span>\
              <span class="s">'equivalent_diameter'</span><span class="p">,</span> <span class="s">'euler_number'</span><span class="p">,</span> <span class="s">'extent'</span><span class="p">,</span> <span class="s">'filled_area'</span><span class="p">,</span>\
              <span class="s">'major_axis_length'</span><span class="p">,</span> <span class="s">'minor_axis_length'</span><span class="p">,</span> <span class="s">'moments_hu1'</span><span class="p">,</span> <span class="s">'moments_hu2'</span><span class="p">,</span>\
              <span class="s">'moments_hu3'</span><span class="p">,</span> <span class="s">'moments_hu4'</span><span class="p">,</span> <span class="s">'moments_hu5'</span><span class="p">,</span> <span class="s">'moments_hu6'</span><span class="p">,</span>\
              <span class="s">'moments_hu7'</span><span class="p">,</span> <span class="s">'perimeter'</span><span class="p">,</span> <span class="s">'solidity'</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">,</span><span class="n">fnames</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>
<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">f</span><span class="p">,</span><span class="n">fnames</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s">'feature vector'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'feature names'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature vector
[2.29250000e+04 4.97420000e+04 2.87890000e+04 8.62091983e-01
 1.70847934e+02 1.00000000e+00 4.60878131e-01 2.29250000e+04
 2.70707528e+02 1.37181534e+02 2.51094162e-01 2.20473857e-02
 6.43740783e-03 1.26777654e-03 2.54548085e-06 1.25658455e-05
 2.57636709e-06 8.24565584e+02 7.96311091e-01]
feature names
('area', 'bbox_area', 'convex_area', 'eccentricity', 'equivalent_diameter', 'euler_number', 'extent', 'filled_area', 'major_axis_length', 'minor_axis_length', 'moments_hu1', 'moments_hu2', 'moments_hu3', 'moments_hu4', 'moments_hu5', 'moments_hu6', 'moments_hu7', 'perimeter', 'solidity')
</code></pre></div></div>

<p>Now we notice that the feature vector is a true vector since we have individually appended each of the 7 Hu moments.  Since there were only 7, we expicitly typed out all seven vector elements and feature names, but note that we could use iteration for longer feature vectors.</p>

<h3 id="section-23-texture-features">Section 2.3: Texture features</h3>
<p>In this section, we will extract a set of features designed to characterize the textures of intensities in an image.  Texture measures characterize the spatial distribution of intensities in an image.  If we think of a grayscale image as a surface where the lighter regions are raised higher than the darker regions, the distribution of those intensities would manifest as different texures if you were to run your finger across the image.  Again, we use the annotation mask as defined above to focus our attention on features only within the object of interest rather than features of the entire image.</p>

<h3 id="section-231-defining-texture-features">Section 2.3.1: Defining texture features</h3>
<p>We create a function <code class="language-plaintext highlighter-rouge">f,fnames=extract_texture_features(im,mask)</code> with inputs <code class="language-plaintext highlighter-rouge">im</code>, the image from which to extract features, and the binary annotation mask, <code class="language-plaintext highlighter-rouge">mask</code>.  This function makes use of the gray-level co-occurrence matrix (GLCM) which is a common method to extract texture features from an image.  The outputs are a length-48 feature vector <code class="language-plaintext highlighter-rouge">f</code> of co-occurrence matrix features within the image object and a length-48 list <code class="language-plaintext highlighter-rouge">fnames</code> with the feature names.</p>
<ul>
  <li>The GLCM is computed for a set of four different orientations $\theta=[0,45,90,135]$ and four different distances $d=[1,2,3,4]$ pixels and for intensities quantized to 32 levels.</li>
  <li>The average and standard deviation of GLCM features are computed across the four orientations for each distance, resulting in features that are reasonably invariant to orientation.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">im</span><span class="o">/</span><span class="mf">255.</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">color</span><span class="p">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">I_q</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="n">I</span><span class="o">*</span><span class="mi">31</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">I_q</span><span class="p">[</span><span class="n">mask</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span> <span class="c1"># an intensity of 32 codes the background pixels
</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">feature</span><span class="p">.</span><span class="n">greycomatrix</span><span class="p">(</span><span class="n">I_q</span><span class="p">,</span><span class="n">distances</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>\
                                 <span class="n">angles</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span><span class="n">levels</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span>\
                                 <span class="n">symmetric</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">32</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">32</span><span class="p">,:,:].</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># remove statistics associated with background pixels
</span>

    <span class="n">GLCM_feats</span> <span class="o">=</span> <span class="p">{</span><span class="s">'contrast'</span><span class="p">,</span> <span class="s">'dissimilarity'</span><span class="p">,</span> <span class="s">'homogeneity'</span><span class="p">,</span> <span class="s">'energy'</span><span class="p">,</span> <span class="s">'correlation'</span><span class="p">,</span> <span class="s">'ASM'</span><span class="p">}</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fnames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">GLCM_feat</span> <span class="ow">in</span> <span class="n">GLCM_feats</span><span class="p">:</span>
        <span class="n">G_feats</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">feature</span><span class="p">.</span><span class="n">greycoprops</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">GLCM_feat</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">G_feats</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">G_feats</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">fnames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">'GLCM_'</span><span class="o">+</span><span class="n">GLCM_feat</span><span class="o">+</span><span class="s">'_d'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="s">'_mean'</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
            <span class="n">fnames</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">'GLCM_'</span><span class="o">+</span><span class="n">GLCM_feat</span><span class="o">+</span><span class="s">'_d'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="s">'_std'</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">,</span> <span class="n">fnames</span>
</code></pre></div></div>

<h3 id="section-232-extracting-texture-features">Section 2.3.2: Extracting texture features</h3>
<p>Using <code class="language-plaintext highlighter-rouge">101_ObjectCategories/emu/image_0001.jpg</code> as in the input image <code class="language-plaintext highlighter-rouge">im</code> and <code class="language-plaintext highlighter-rouge">Annotations/emu/annotation_0001.mat</code> as the annotation mask <code class="language-plaintext highlighter-rouge">mask</code>, we use the <code class="language-plaintext highlighter-rouge">extract_texture_features</code> function and print out the <code class="language-plaintext highlighter-rouge">f</code> vector and the <code class="language-plaintext highlighter-rouge">fnames</code> list.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="s">'101_ObjectCategories/emu/image_0001.jpg'</span><span class="p">))</span>
<span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="s">'Annotations/emu/annotation_0001.mat'</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                           <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">f</span><span class="p">,</span><span class="n">fnames</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'feature vector'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'feature names'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>feature vector
[6.11324265e-01 5.59225027e-01 4.79792054e-01 4.29846997e-01
 4.12875202e-02 2.94518620e-02 1.22013521e-02 1.04584654e-02
 9.44795021e-03 8.91621988e-03 8.49414681e-03 8.26354227e-03
 6.40602380e-04 3.13705857e-04 1.51332668e-04 1.57924464e-04
 9.71457997e-02 9.44111478e-02 9.21600423e-02 9.08999193e-02
 3.26248410e-03 1.65983452e-03 8.20617638e-04 8.64257319e-04
 2.60085612e+00 2.75670895e+00 2.96004591e+00 3.09156989e+00
 1.20573130e-01 8.59555132e-02 4.33562527e-02 5.85714661e-02
 3.72965154e-01 3.55317937e-01 3.37690195e-01 3.26456920e-01
 1.91489099e-02 1.13961311e-02 7.42917505e-03 8.08769450e-03
 1.56044800e+01 1.74694492e+01 2.01266035e+01 2.17261141e+01
 1.57594074e+00 1.06371099e+00 5.02286894e-01 4.12576946e-01]
feature names
['GLCM_correlation_d1_mean', 'GLCM_correlation_d2_mean', 'GLCM_correlation_d3_mean', 'GLCM_correlation_d4_mean', 'GLCM_correlation_d1_std', 'GLCM_correlation_d2_std', 'GLCM_correlation_d3_std', 'GLCM_correlation_d4_std', 'GLCM_ASM_d1_mean', 'GLCM_ASM_d2_mean', 'GLCM_ASM_d3_mean', 'GLCM_ASM_d4_mean', 'GLCM_ASM_d1_std', 'GLCM_ASM_d2_std', 'GLCM_ASM_d3_std', 'GLCM_ASM_d4_std', 'GLCM_energy_d1_mean', 'GLCM_energy_d2_mean', 'GLCM_energy_d3_mean', 'GLCM_energy_d4_mean', 'GLCM_energy_d1_std', 'GLCM_energy_d2_std', 'GLCM_energy_d3_std', 'GLCM_energy_d4_std', 'GLCM_dissimilarity_d1_mean', 'GLCM_dissimilarity_d2_mean', 'GLCM_dissimilarity_d3_mean', 'GLCM_dissimilarity_d4_mean', 'GLCM_dissimilarity_d1_std', 'GLCM_dissimilarity_d2_std', 'GLCM_dissimilarity_d3_std', 'GLCM_dissimilarity_d4_std', 'GLCM_homogeneity_d1_mean', 'GLCM_homogeneity_d2_mean', 'GLCM_homogeneity_d3_mean', 'GLCM_homogeneity_d4_mean', 'GLCM_homogeneity_d1_std', 'GLCM_homogeneity_d2_std', 'GLCM_homogeneity_d3_std', 'GLCM_homogeneity_d4_std', 'GLCM_contrast_d1_mean', 'GLCM_contrast_d2_mean', 'GLCM_contrast_d3_mean', 'GLCM_contrast_d4_mean', 'GLCM_contrast_d1_std', 'GLCM_contrast_d2_std', 'GLCM_contrast_d3_std', 'GLCM_contrast_d4_std']
</code></pre></div></div>

<h2 id="section-3-setting-up-a-feature-matrix-and-label-vector">Section 3: Setting up a Feature Matrix and Label Vector</h2>
<p>Now that we have defined functions that compute several different categories of features from an image object, we need to aggregate those features into a feature matrix.  This feature matrix will be  $N\times M$ where $N$ is the total number of images that we use as input and $M$ is the total number of features that we extract from each of the $N$ images. If we use all features from above we have a total of 97 features for each image (97 = 15 RGB features + 15 HSV features + 19 region features + 48 texture features).  This feature matrix is used as input to the classification algorithm to describe the image objects.</p>

<p>The classification algorithm, however, also needs to be told what the label of each image is so that it can learn to discriminate the different objects.  The label vector will be an $N\times 1$ vector.  Note that the number of rows $N$ in the feature matrix must correspond to the length $N$ of the label vector and there must be a one-to-one correspondence, i.e., the first row of the feature matrix must correspond to the first element in the label vector.  This label vector provides the identity (label) of each image.  There are different means to define labels for machine learning algorithms.  This example will be specific to the <code class="language-plaintext highlighter-rouge">sklearn</code> package in python, but will be similar in flavor to necessary format for other frameworks.  We will learn a different formulation of the label vector for deep learning in Tutorial 3.</p>

<h3 id="section-31-setting-up-a-matrix-to-discriminate-between-flamingos-and-emus">Section 3.1: Setting up a matrix to discriminate between flamingos and emus</h3>
<p>In this part, we use what we learned from Section 1 above about looping over the directory structure of the CalTech101 dataset.  We will loop over multiple images, extract features, and build a feature matrix and label vector.  We write this code so that the user can specify the categories of interest as a list of strings.  Those strings are used to navigate into the directories of images from which to extract features.  Feature vectors <code class="language-plaintext highlighter-rouge">f_rgb</code>, <code class="language-plaintext highlighter-rouge">f_hsv</code>, <code class="language-plaintext highlighter-rouge">f_region</code>,  and <code class="language-plaintext highlighter-rouge">f_texture</code> are extracted from each image and stacked in an $N\times97$ feature matrix, where $N$ is the total number of images, and 97 is the feature vector dimensionality.  At the same time, we create a corresponding $N\times1$ label vector (actually a list in python).</p>

<p>While we loop over all images in the specified categories, we split the data into a training set consisting of 90% of the data and a test set consisting of the remaining 10%.  We call the two feature matrices <code class="language-plaintext highlighter-rouge">X_train</code> and <code class="language-plaintext highlighter-rouge">X_test</code> and the  two label vectors, <code class="language-plaintext highlighter-rouge">y_train</code> and <code class="language-plaintext highlighter-rouge">y_test</code>, consistent with common notation in machine learning.  In this case, the label vectors <code class="language-plaintext highlighter-rouge">y_train</code> and <code class="language-plaintext highlighter-rouge">y_test</code> are actually lists of the class strings (e.g., <code class="language-plaintext highlighter-rouge">'emu'</code>).</p>

<p>Here, as an example, we specify the <code class="language-plaintext highlighter-rouge">'emu'</code> and <code class="language-plaintext highlighter-rouge">'flamingo'</code> directories, compute <code class="language-plaintext highlighter-rouge">X_train</code>, <code class="language-plaintext highlighter-rouge">X_test</code>, <code class="language-plaintext highlighter-rouge">y_train</code>, and <code class="language-plaintext highlighter-rouge">y_test</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span>

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">filenames_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">filenames_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
            <span class="n">filenames_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">im_filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
            <span class="n">filenames_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">im_filename</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="-your-turn--4"><span style="color:Green"> Your turn: </span></h2>
<p>Explore the dimensionalities and values of <code class="language-plaintext highlighter-rouge">X_train</code>, <code class="language-plaintext highlighter-rouge">X_test</code>, <code class="language-plaintext highlighter-rouge">y_train</code>, and <code class="language-plaintext highlighter-rouge">y_test</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">'X_train is shape '</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">X_train</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'X_test is shape '</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">X_test</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'y_train is length '</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'y_test is length '</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_test</span><span class="p">)))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>X_train is shape (107, 97)
X_test is shape (13, 97)
y_train is length 107
y_test is length 13
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">filenames_train</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['101_ObjectCategories/emu/image_0001.jpg',
 '101_ObjectCategories/emu/image_0002.jpg',
 '101_ObjectCategories/emu/image_0003.jpg',
 '101_ObjectCategories/emu/image_0004.jpg',
 '101_ObjectCategories/emu/image_0005.jpg',
 '101_ObjectCategories/emu/image_0006.jpg',
 '101_ObjectCategories/emu/image_0007.jpg',
 '101_ObjectCategories/emu/image_0008.jpg',
 '101_ObjectCategories/emu/image_0009.jpg',
 '101_ObjectCategories/emu/image_0010.jpg',
 '101_ObjectCategories/emu/image_0011.jpg',
 '101_ObjectCategories/emu/image_0012.jpg',
 '101_ObjectCategories/emu/image_0013.jpg',
 '101_ObjectCategories/emu/image_0014.jpg',
 '101_ObjectCategories/emu/image_0015.jpg',
 '101_ObjectCategories/emu/image_0016.jpg',
 '101_ObjectCategories/emu/image_0017.jpg',
 '101_ObjectCategories/emu/image_0018.jpg',
 '101_ObjectCategories/emu/image_0019.jpg',
 '101_ObjectCategories/emu/image_0020.jpg',
 '101_ObjectCategories/emu/image_0021.jpg',
 '101_ObjectCategories/emu/image_0022.jpg',
 '101_ObjectCategories/emu/image_0023.jpg',
 '101_ObjectCategories/emu/image_0024.jpg',
 '101_ObjectCategories/emu/image_0025.jpg',
 '101_ObjectCategories/emu/image_0026.jpg',
 '101_ObjectCategories/emu/image_0027.jpg',
 '101_ObjectCategories/emu/image_0028.jpg',
 '101_ObjectCategories/emu/image_0029.jpg',
 '101_ObjectCategories/emu/image_0030.jpg',
 '101_ObjectCategories/emu/image_0031.jpg',
 '101_ObjectCategories/emu/image_0032.jpg',
 '101_ObjectCategories/emu/image_0033.jpg',
 '101_ObjectCategories/emu/image_0034.jpg',
 '101_ObjectCategories/emu/image_0035.jpg',
 '101_ObjectCategories/emu/image_0036.jpg',
 '101_ObjectCategories/emu/image_0037.jpg',
 '101_ObjectCategories/emu/image_0038.jpg',
 '101_ObjectCategories/emu/image_0039.jpg',
 '101_ObjectCategories/emu/image_0040.jpg',
 '101_ObjectCategories/emu/image_0041.jpg',
 '101_ObjectCategories/emu/image_0042.jpg',
 '101_ObjectCategories/emu/image_0043.jpg',
 '101_ObjectCategories/emu/image_0044.jpg',
 '101_ObjectCategories/emu/image_0045.jpg',
 '101_ObjectCategories/emu/image_0046.jpg',
 '101_ObjectCategories/emu/image_0047.jpg',
 '101_ObjectCategories/flamingo/image_0001.jpg',
 '101_ObjectCategories/flamingo/image_0002.jpg',
 '101_ObjectCategories/flamingo/image_0003.jpg',
 '101_ObjectCategories/flamingo/image_0004.jpg',
 '101_ObjectCategories/flamingo/image_0005.jpg',
 '101_ObjectCategories/flamingo/image_0006.jpg',
 '101_ObjectCategories/flamingo/image_0007.jpg',
 '101_ObjectCategories/flamingo/image_0008.jpg',
 '101_ObjectCategories/flamingo/image_0009.jpg',
 '101_ObjectCategories/flamingo/image_0010.jpg',
 '101_ObjectCategories/flamingo/image_0011.jpg',
 '101_ObjectCategories/flamingo/image_0012.jpg',
 '101_ObjectCategories/flamingo/image_0013.jpg',
 '101_ObjectCategories/flamingo/image_0014.jpg',
 '101_ObjectCategories/flamingo/image_0015.jpg',
 '101_ObjectCategories/flamingo/image_0016.jpg',
 '101_ObjectCategories/flamingo/image_0017.jpg',
 '101_ObjectCategories/flamingo/image_0018.jpg',
 '101_ObjectCategories/flamingo/image_0019.jpg',
 '101_ObjectCategories/flamingo/image_0020.jpg',
 '101_ObjectCategories/flamingo/image_0021.jpg',
 '101_ObjectCategories/flamingo/image_0022.jpg',
 '101_ObjectCategories/flamingo/image_0023.jpg',
 '101_ObjectCategories/flamingo/image_0024.jpg',
 '101_ObjectCategories/flamingo/image_0025.jpg',
 '101_ObjectCategories/flamingo/image_0026.jpg',
 '101_ObjectCategories/flamingo/image_0027.jpg',
 '101_ObjectCategories/flamingo/image_0028.jpg',
 '101_ObjectCategories/flamingo/image_0029.jpg',
 '101_ObjectCategories/flamingo/image_0030.jpg',
 '101_ObjectCategories/flamingo/image_0031.jpg',
 '101_ObjectCategories/flamingo/image_0032.jpg',
 '101_ObjectCategories/flamingo/image_0033.jpg',
 '101_ObjectCategories/flamingo/image_0034.jpg',
 '101_ObjectCategories/flamingo/image_0035.jpg',
 '101_ObjectCategories/flamingo/image_0036.jpg',
 '101_ObjectCategories/flamingo/image_0037.jpg',
 '101_ObjectCategories/flamingo/image_0038.jpg',
 '101_ObjectCategories/flamingo/image_0039.jpg',
 '101_ObjectCategories/flamingo/image_0040.jpg',
 '101_ObjectCategories/flamingo/image_0041.jpg',
 '101_ObjectCategories/flamingo/image_0042.jpg',
 '101_ObjectCategories/flamingo/image_0043.jpg',
 '101_ObjectCategories/flamingo/image_0044.jpg',
 '101_ObjectCategories/flamingo/image_0045.jpg',
 '101_ObjectCategories/flamingo/image_0046.jpg',
 '101_ObjectCategories/flamingo/image_0047.jpg',
 '101_ObjectCategories/flamingo/image_0048.jpg',
 '101_ObjectCategories/flamingo/image_0049.jpg',
 '101_ObjectCategories/flamingo/image_0050.jpg',
 '101_ObjectCategories/flamingo/image_0051.jpg',
 '101_ObjectCategories/flamingo/image_0052.jpg',
 '101_ObjectCategories/flamingo/image_0053.jpg',
 '101_ObjectCategories/flamingo/image_0054.jpg',
 '101_ObjectCategories/flamingo/image_0055.jpg',
 '101_ObjectCategories/flamingo/image_0056.jpg',
 '101_ObjectCategories/flamingo/image_0057.jpg',
 '101_ObjectCategories/flamingo/image_0058.jpg',
 '101_ObjectCategories/flamingo/image_0059.jpg',
 '101_ObjectCategories/flamingo/image_0060.jpg']
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_test</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['emu',
 'emu',
 'emu',
 'emu',
 'emu',
 'emu',
 'flamingo',
 'flamingo',
 'flamingo',
 'flamingo',
 'flamingo',
 'flamingo',
 'flamingo']
</code></pre></div></div>

<h3 id="section-32-normalizing-the-feature-matrices">Section 3.2: Normalizing the feature matrices</h3>
<p>Some of the features have a larger range than others.  We don’t want those features to have undue influence on the classification.  We will thus normalize the feature matrices to have range [0,1].  There will be two slightly different procedures for normalizing <code class="language-plaintext highlighter-rouge">X_train</code> and <code class="language-plaintext highlighter-rouge">X_test</code>.</p>

<p>To normalize <code class="language-plaintext highlighter-rouge">X_train</code>, from each column we subtract the minimum of the column and divide by the maximum of the column. Additionally, we save the maximum values for each column in a $1\times97$ vector <code class="language-plaintext highlighter-rouge">mx</code> and the minimum values for each column in a $1\times97$ vector <code class="language-plaintext highlighter-rouge">mn</code>.</p>

<p>To normalize <code class="language-plaintext highlighter-rouge">X_test</code>, from each column we subtract the corresponding minimum from <code class="language-plaintext highlighter-rouge">mn</code> and divide by the corresponding maximum from <code class="language-plaintext highlighter-rouge">mx</code>.  This procedure treats the test data exactly the same as the training data.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">normalize_feature_columns</span><span class="p">(</span><span class="o">*</span><span class="n">argv</span><span class="p">):</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">amin</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># minimum of feature (along columns)
</span>        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">),</span><span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mn</span><span class="p">))</span> <span class="c1"># zero minimum
</span>        <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">amax</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">mx</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">X</span><span class="p">[:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="n">f</span><span class="p">]</span><span class="o">/</span><span class="n">mx</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mn</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">ones</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">),</span><span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mn</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">mx</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">X</span><span class="p">[:,</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="n">f</span><span class="p">]</span><span class="o">/</span><span class="n">mx</span><span class="p">[</span><span class="n">f</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">X</span>
</code></pre></div></div>

<h2 id="-your-turn--5"><span style="color:Green"> Your turn: </span></h2>
<p>For the same <code class="language-plaintext highlighter-rouge">X_train</code>, <code class="language-plaintext highlighter-rouge">X_test</code> as in Section 3.1, compute the normalized matrices <code class="language-plaintext highlighter-rouge">Xn_train</code>, <code class="language-plaintext highlighter-rouge">Xn_test</code>.  Explore the dimensionalities and values of <code class="language-plaintext highlighter-rouge">Xn_train</code> and <code class="language-plaintext highlighter-rouge">Xn_test</code> and compare to what you found above for <code class="language-plaintext highlighter-rouge">X_train</code> and <code class="language-plaintext highlighter-rouge">X_test</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">mx</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">10</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">mn</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">10</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[1.62585068e+02 1.49270702e+02 6.62355494e-01 4.11760000e+04
 4.94653353e-01 7.29980052e-01 4.11441678e-02 7.78317514e-03
 7.58791574e-01 1.14100275e+02]
[5.92357806e+01 4.65543384e+01 0.00000000e+00 3.22500000e+03
 1.82432150e-01 2.35479973e-01 1.56000740e-03 2.71493316e-04
 1.98773687e-02 1.09397469e+00]
[[0.18714424 0.30808148 0.2184466  ... 0.08276854 0.04043092 0.01677172]
 [0.37860799 0.53429145 0.33009709 ... 0.3573213  0.18900107 0.12418165]
 [0.         0.41250965 0.         ... 0.04236502 0.0725881  0.09919185]
 ...
 [0.79179517 0.51591778 0.75728155 ... 0.18946762 0.25496932 0.29846329]
 [0.5683703  0.36744634 0.45631068 ... 0.12068367 0.12440309 0.15122178]
 [0.52946132 0.3911888  0.55825243 ... 0.09361418 0.12736017 0.1760575 ]] 0
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Xn_train</span><span class="p">.</span><span class="nb">min</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.0
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Xn_train</span><span class="p">.</span><span class="nb">max</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.0
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">[:,</span><span class="mi">0</span><span class="p">].</span><span class="n">T</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[0.3936947  0.12898959 0.37507987 0.25596447 0.49204136 0.30238921
 0.54268833 0.88367621 0.5326359  0.7839688  0.59299773 0.39906093
 0.92917099]
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Xn_test</span><span class="p">.</span><span class="nb">min</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-0.5476190476190478
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Xn_test</span><span class="p">.</span><span class="nb">max</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.980450033113281
</code></pre></div></div>

<h2 id="section-4-classification">Section 4: Classification</h2>
<p>In this section we will use the support vector machine (SVM) classifier from <code class="language-plaintext highlighter-rouge">sklearn</code> as an example for how you can use the training data in <code class="language-plaintext highlighter-rouge">X_train</code> and <code class="language-plaintext highlighter-rouge">y_train</code> to train a classifier.  We we also use other supporting functions from <code class="language-plaintext highlighter-rouge">sklearn</code> to assess the performance of the SVM on the test data <code class="language-plaintext highlighter-rouge">X_test</code>.  The basic setup of the training and testing process for the SVM will be easily transferred to application of other common classifiers available in <code class="language-plaintext highlighter-rouge">sklearn</code>.</p>

<p>We will also explore modifications to the training process to explore some of the discriminative capabilities of the features we have extracted.  Finally, you will explore other standard classifiers available in <code class="language-plaintext highlighter-rouge">sklearn</code>.</p>

<h3 id="section-41-training-the-svm-classifier">Section 4.1: Training the SVM Classifier</h3>
<p>The commands here assume that we will be training a binary (two-class) classifier <code class="language-plaintext highlighter-rouge">svm.SVC</code>.  We first declare the SVM which is the step where we can configure various parameters of the SVM.  Next, we fit the SVM to the data.  You will notice that the fitting routine prints out a bunch of information about the classifier that was trained. That information gives us some idea about the different configuration parameters available in the SVM classifier.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SVC(kernel='linear')
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">help</span><span class="p">(</span><span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Help on class SVC in module sklearn.svm._classes:

class SVC(sklearn.svm._base.BaseSVC)
 |  SVC(*, C=1.0, kernel='rbf', degree=3, gamma='scale', coef0=0.0, shrinking=True, probability=False, tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape='ovr', break_ties=False, random_state=None)
 |  
 |  C-Support Vector Classification.
 |  
 |  The implementation is based on libsvm. The fit time scales at least
 |  quadratically with the number of samples and may be impractical
 |  beyond tens of thousands of samples. For large datasets
 |  consider using :class:`sklearn.svm.LinearSVC` or
 |  :class:`sklearn.linear_model.SGDClassifier` instead, possibly after a
 |  :class:`sklearn.kernel_approximation.Nystroem` transformer.
 |  
 |  The multiclass support is handled according to a one-vs-one scheme.
 |  
 |  For details on the precise mathematical formulation of the provided
 |  kernel functions and how `gamma`, `coef0` and `degree` affect each
 |  other, see the corresponding section in the narrative documentation:
 |  :ref:`svm_kernels`.
 |  
 |  Read more in the :ref:`User Guide &lt;svm_classification&gt;`.
 |  
 |  Parameters
 |  ----------
 |  C : float, default=1.0
 |      Regularization parameter. The strength of the regularization is
 |      inversely proportional to C. Must be strictly positive. The penalty
 |      is a squared l2 penalty.
 |  
 |  kernel : {'linear', 'poly', 'rbf', 'sigmoid', 'precomputed'}, default='rbf'
 |      Specifies the kernel type to be used in the algorithm.
 |      It must be one of 'linear', 'poly', 'rbf', 'sigmoid', 'precomputed' or
 |      a callable.
 |      If none is given, 'rbf' will be used. If a callable is given it is
 |      used to pre-compute the kernel matrix from data matrices; that matrix
 |      should be an array of shape ``(n_samples, n_samples)``.
 |  
 |  degree : int, default=3
 |      Degree of the polynomial kernel function ('poly').
 |      Ignored by all other kernels.
 |  
 |  gamma : {'scale', 'auto'} or float, default='scale'
 |      Kernel coefficient for 'rbf', 'poly' and 'sigmoid'.
 |  
 |      - if ``gamma='scale'`` (default) is passed then it uses
 |        1 / (n_features * X.var()) as value of gamma,
 |      - if 'auto', uses 1 / n_features.
 |  
 |      .. versionchanged:: 0.22
 |         The default value of ``gamma`` changed from 'auto' to 'scale'.
 |  
 |  coef0 : float, default=0.0
 |      Independent term in kernel function.
 |      It is only significant in 'poly' and 'sigmoid'.
 |  
 |  shrinking : bool, default=True
 |      Whether to use the shrinking heuristic.
 |      See the :ref:`User Guide &lt;shrinking_svm&gt;`.
 |  
 |  probability : bool, default=False
 |      Whether to enable probability estimates. This must be enabled prior
 |      to calling `fit`, will slow down that method as it internally uses
 |      5-fold cross-validation, and `predict_proba` may be inconsistent with
 |      `predict`. Read more in the :ref:`User Guide &lt;scores_probabilities&gt;`.
 |  
 |  tol : float, default=1e-3
 |      Tolerance for stopping criterion.
 |  
 |  cache_size : float, default=200
 |      Specify the size of the kernel cache (in MB).
 |  
 |  class_weight : dict or 'balanced', default=None
 |      Set the parameter C of class i to class_weight[i]*C for
 |      SVC. If not given, all classes are supposed to have
 |      weight one.
 |      The "balanced" mode uses the values of y to automatically adjust
 |      weights inversely proportional to class frequencies in the input data
 |      as ``n_samples / (n_classes * np.bincount(y))``
 |  
 |  verbose : bool, default=False
 |      Enable verbose output. Note that this setting takes advantage of a
 |      per-process runtime setting in libsvm that, if enabled, may not work
 |      properly in a multithreaded context.
 |  
 |  max_iter : int, default=-1
 |      Hard limit on iterations within solver, or -1 for no limit.
 |  
 |  decision_function_shape : {'ovo', 'ovr'}, default='ovr'
 |      Whether to return a one-vs-rest ('ovr') decision function of shape
 |      (n_samples, n_classes) as all other classifiers, or the original
 |      one-vs-one ('ovo') decision function of libsvm which has shape
 |      (n_samples, n_classes * (n_classes - 1) / 2). However, one-vs-one
 |      ('ovo') is always used as multi-class strategy. The parameter is
 |      ignored for binary classification.
 |  
 |      .. versionchanged:: 0.19
 |          decision_function_shape is 'ovr' by default.
 |  
 |      .. versionadded:: 0.17
 |         *decision_function_shape='ovr'* is recommended.
 |  
 |      .. versionchanged:: 0.17
 |         Deprecated *decision_function_shape='ovo' and None*.
 |  
 |  break_ties : bool, default=False
 |      If true, ``decision_function_shape='ovr'``, and number of classes &gt; 2,
 |      :term:`predict` will break ties according to the confidence values of
 |      :term:`decision_function`; otherwise the first class among the tied
 |      classes is returned. Please note that breaking ties comes at a
 |      relatively high computational cost compared to a simple predict.
 |  
 |      .. versionadded:: 0.22
 |  
 |  random_state : int or RandomState instance, default=None
 |      Controls the pseudo random number generation for shuffling the data for
 |      probability estimates. Ignored when `probability` is False.
 |      Pass an int for reproducible output across multiple function calls.
 |      See :term:`Glossary &lt;random_state&gt;`.
 |  
 |  Attributes
 |  ----------
 |  support_ : ndarray of shape (n_SV,)
 |      Indices of support vectors.
 |  
 |  support_vectors_ : ndarray of shape (n_SV, n_features)
 |      Support vectors.
 |  
 |  n_support_ : ndarray of shape (n_class,), dtype=int32
 |      Number of support vectors for each class.
 |  
 |  dual_coef_ : ndarray of shape (n_class-1, n_SV)
 |      Dual coefficients of the support vector in the decision
 |      function (see :ref:`sgd_mathematical_formulation`), multiplied by
 |      their targets.
 |      For multiclass, coefficient for all 1-vs-1 classifiers.
 |      The layout of the coefficients in the multiclass case is somewhat
 |      non-trivial. See the :ref:`multi-class section of the User Guide
 |      &lt;svm_multi_class&gt;` for details.
 |  
 |  coef_ : ndarray of shape (n_class * (n_class-1) / 2, n_features)
 |      Weights assigned to the features (coefficients in the primal
 |      problem). This is only available in the case of a linear kernel.
 |  
 |      `coef_` is a readonly property derived from `dual_coef_` and
 |      `support_vectors_`.
 |  
 |  intercept_ : ndarray of shape (n_class * (n_class-1) / 2,)
 |      Constants in decision function.
 |  
 |  fit_status_ : int
 |      0 if correctly fitted, 1 otherwise (will raise warning)
 |  
 |  classes_ : ndarray of shape (n_classes,)
 |      The classes labels.
 |  
 |  probA_ : ndarray of shape (n_class * (n_class-1) / 2)
 |  probB_ : ndarray of shape (n_class * (n_class-1) / 2)
 |      If `probability=True`, it corresponds to the parameters learned in
 |      Platt scaling to produce probability estimates from decision values.
 |      If `probability=False`, it's an empty array. Platt scaling uses the
 |      logistic function
 |      ``1 / (1 + exp(decision_value * probA_ + probB_))``
 |      where ``probA_`` and ``probB_`` are learned from the dataset [2]_. For
 |      more information on the multiclass case and training procedure see
 |      section 8 of [1]_.
 |  
 |  class_weight_ : ndarray of shape (n_class,)
 |      Multipliers of parameter C for each class.
 |      Computed based on the ``class_weight`` parameter.
 |  
 |  shape_fit_ : tuple of int of shape (n_dimensions_of_X,)
 |      Array dimensions of training vector ``X``.
 |  
 |  Examples
 |  --------
 |  &gt;&gt;&gt; import numpy as np
 |  &gt;&gt;&gt; from sklearn.pipeline import make_pipeline
 |  &gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
 |  &gt;&gt;&gt; X = np.array([[-1, -1], [-2, -1], [1, 1], [2, 1]])
 |  &gt;&gt;&gt; y = np.array([1, 1, 2, 2])
 |  &gt;&gt;&gt; from sklearn.svm import SVC
 |  &gt;&gt;&gt; clf = make_pipeline(StandardScaler(), SVC(gamma='auto'))
 |  &gt;&gt;&gt; clf.fit(X, y)
 |  Pipeline(steps=[('standardscaler', StandardScaler()),
 |                  ('svc', SVC(gamma='auto'))])
 |  
 |  &gt;&gt;&gt; print(clf.predict([[-0.8, -1]]))
 |  [1]
 |  
 |  See also
 |  --------
 |  SVR
 |      Support Vector Machine for Regression implemented using libsvm.
 |  
 |  LinearSVC
 |      Scalable Linear Support Vector Machine for classification
 |      implemented using liblinear. Check the See also section of
 |      LinearSVC for more comparison element.
 |  
 |  References
 |  ----------
 |  .. [1] `LIBSVM: A Library for Support Vector Machines
 |      &lt;http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf&gt;`_
 |  
 |  .. [2] `Platt, John (1999). "Probabilistic outputs for support vector
 |      machines and comparison to regularizedlikelihood methods."
 |      &lt;http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.1639&gt;`_
 |  
 |  Method resolution order:
 |      SVC
 |      sklearn.svm._base.BaseSVC
 |      sklearn.base.ClassifierMixin
 |      sklearn.svm._base.BaseLibSVM
 |      sklearn.base.BaseEstimator
 |      builtins.object
 |  
 |  Methods defined here:
 |  
 |  __init__(self, *, C=1.0, kernel='rbf', degree=3, gamma='scale', coef0=0.0, shrinking=True, probability=False, tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape='ovr', break_ties=False, random_state=None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |  
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |  
 |  __abstractmethods__ = frozenset()
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from sklearn.svm._base.BaseSVC:
 |  
 |  decision_function(self, X)
 |      Evaluates the decision function for the samples in X.
 |      
 |      Parameters
 |      ----------
 |      X : array-like of shape (n_samples, n_features)
 |      
 |      Returns
 |      -------
 |      X : ndarray of shape (n_samples, n_classes * (n_classes-1) / 2)
 |          Returns the decision function of the sample for each class
 |          in the model.
 |          If decision_function_shape='ovr', the shape is (n_samples,
 |          n_classes).
 |      
 |      Notes
 |      -----
 |      If decision_function_shape='ovo', the function values are proportional
 |      to the distance of the samples X to the separating hyperplane. If the
 |      exact distances are required, divide the function values by the norm of
 |      the weight vector (``coef_``). See also `this question
 |      &lt;https://stats.stackexchange.com/questions/14876/
 |      interpreting-distance-from-hyperplane-in-svm&gt;`_ for further details.
 |      If decision_function_shape='ovr', the decision function is a monotonic
 |      transformation of ovo decision function.
 |  
 |  predict(self, X)
 |      Perform classification on samples in X.
 |      
 |      For an one-class model, +1 or -1 is returned.
 |      
 |      Parameters
 |      ----------
 |      X : {array-like, sparse matrix} of shape (n_samples, n_features) or                 (n_samples_test, n_samples_train)
 |          For kernel="precomputed", the expected shape of X is
 |          (n_samples_test, n_samples_train).
 |      
 |      Returns
 |      -------
 |      y_pred : ndarray of shape (n_samples,)
 |          Class labels for samples in X.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from sklearn.svm._base.BaseSVC:
 |  
 |  predict_log_proba
 |      Compute log probabilities of possible outcomes for samples in X.
 |      
 |      The model need to have probability information computed at training
 |      time: fit with attribute `probability` set to True.
 |      
 |      Parameters
 |      ----------
 |      X : array-like of shape (n_samples, n_features) or                 (n_samples_test, n_samples_train)
 |          For kernel="precomputed", the expected shape of X is
 |          (n_samples_test, n_samples_train).
 |      
 |      Returns
 |      -------
 |      T : ndarray of shape (n_samples, n_classes)
 |          Returns the log-probabilities of the sample for each class in
 |          the model. The columns correspond to the classes in sorted
 |          order, as they appear in the attribute :term:`classes_`.
 |      
 |      Notes
 |      -----
 |      The probability model is created using cross validation, so
 |      the results can be slightly different than those obtained by
 |      predict. Also, it will produce meaningless results on very small
 |      datasets.
 |  
 |  predict_proba
 |      Compute probabilities of possible outcomes for samples in X.
 |      
 |      The model need to have probability information computed at training
 |      time: fit with attribute `probability` set to True.
 |      
 |      Parameters
 |      ----------
 |      X : array-like of shape (n_samples, n_features)
 |          For kernel="precomputed", the expected shape of X is
 |          [n_samples_test, n_samples_train]
 |      
 |      Returns
 |      -------
 |      T : ndarray of shape (n_samples, n_classes)
 |          Returns the probability of the sample for each class in
 |          the model. The columns correspond to the classes in sorted
 |          order, as they appear in the attribute :term:`classes_`.
 |      
 |      Notes
 |      -----
 |      The probability model is created using cross validation, so
 |      the results can be slightly different than those obtained by
 |      predict. Also, it will produce meaningless results on very small
 |      datasets.
 |  
 |  probA_
 |  
 |  probB_
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from sklearn.base.ClassifierMixin:
 |  
 |  score(self, X, y, sample_weight=None)
 |      Return the mean accuracy on the given test data and labels.
 |      
 |      In multi-label classification, this is the subset accuracy
 |      which is a harsh metric since you require for each sample that
 |      each label set be correctly predicted.
 |      
 |      Parameters
 |      ----------
 |      X : array-like of shape (n_samples, n_features)
 |          Test samples.
 |      
 |      y : array-like of shape (n_samples,) or (n_samples, n_outputs)
 |          True labels for X.
 |      
 |      sample_weight : array-like of shape (n_samples,), default=None
 |          Sample weights.
 |      
 |      Returns
 |      -------
 |      score : float
 |          Mean accuracy of self.predict(X) wrt. y.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from sklearn.base.ClassifierMixin:
 |  
 |  __dict__
 |      dictionary for instance variables (if defined)
 |  
 |  __weakref__
 |      list of weak references to the object (if defined)
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from sklearn.svm._base.BaseLibSVM:
 |  
 |  fit(self, X, y, sample_weight=None)
 |      Fit the SVM model according to the given training data.
 |      
 |      Parameters
 |      ----------
 |      X : {array-like, sparse matrix} of shape (n_samples, n_features)                 or (n_samples, n_samples)
 |          Training vectors, where n_samples is the number of samples
 |          and n_features is the number of features.
 |          For kernel="precomputed", the expected shape of X is
 |          (n_samples, n_samples).
 |      
 |      y : array-like of shape (n_samples,)
 |          Target values (class labels in classification, real numbers in
 |          regression)
 |      
 |      sample_weight : array-like of shape (n_samples,), default=None
 |          Per-sample weights. Rescale C per sample. Higher weights
 |          force the classifier to put more emphasis on these points.
 |      
 |      Returns
 |      -------
 |      self : object
 |      
 |      Notes
 |      -----
 |      If X and y are not C-ordered and contiguous arrays of np.float64 and
 |      X is not a scipy.sparse.csr_matrix, X and/or y may be copied.
 |      
 |      If X is a dense array, then the other methods will not support sparse
 |      matrices as input.
 |  
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from sklearn.svm._base.BaseLibSVM:
 |  
 |  coef_
 |  
 |  n_support_
 |  
 |  ----------------------------------------------------------------------
 |  Methods inherited from sklearn.base.BaseEstimator:
 |  
 |  __getstate__(self)
 |  
 |  __repr__(self, N_CHAR_MAX=700)
 |      Return repr(self).
 |  
 |  __setstate__(self, state)
 |  
 |  get_params(self, deep=True)
 |      Get parameters for this estimator.
 |      
 |      Parameters
 |      ----------
 |      deep : bool, default=True
 |          If True, will return the parameters for this estimator and
 |          contained subobjects that are estimators.
 |      
 |      Returns
 |      -------
 |      params : mapping of string to any
 |          Parameter names mapped to their values.
 |  
 |  set_params(self, **params)
 |      Set the parameters of this estimator.
 |      
 |      The method works on simple estimators as well as on nested objects
 |      (such as pipelines). The latter have parameters of the form
 |      ``&lt;component&gt;__&lt;parameter&gt;`` so that it's possible to update each
 |      component of a nested object.
 |      
 |      Parameters
 |      ----------
 |      **params : dict
 |          Estimator parameters.
 |      
 |      Returns
 |      -------
 |      self : object
 |          Estimator instance.
</code></pre></div></div>

<h3 id="section-42-testing-the-svm-classifier">Section 4.2: Testing the SVM Classifier</h3>
<p>Now that we have trained the classifier by showing it the training data, we will test your classifier by predicting the labels for the test data.  We call the predicted labels <code class="language-plaintext highlighter-rouge">y_test_hat</code> where the <code class="language-plaintext highlighter-rouge">_hat</code> is in nod to the typical mathematical notation for an estimate.  Now that we have the predicted class labels <code class="language-plaintext highlighter-rouge">y_test_hat</code>, we compare them to the known class labels in <code class="language-plaintext highlighter-rouge">y_test</code>.  Here, we use two metrics to help us interpret the performance: the confusion matrix and the accuracy.  There are many other metrics available, see the documentation for <code class="language-plaintext highlighter-rouge">sklearn</code> at  https://scikit-learn.org/stable/user_guide.html.</p>

<p>The confusion matrix is a matrix of $L\times L$ where $L$ is the number of classes.  The $(i,j)$-th entry is a count of the number of times an actual class $i$ is predicted to be class $j$.  Thus, a perfect prediction will have a diagonal confusion matrix.  We also send in the list of category names to specify the order in which the classes appear in the confusion matrix.</p>

<p>We compute the overall classification accuracy from the confusion matrix by summing the diagonal of <code class="language-plaintext highlighter-rouge">C</code> (the number of correct classifications) by the total of <code class="language-plaintext highlighter-rouge">C</code> (the total number of training samples)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">,</span><span class="n">categories</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The confusion matrix is:
[[6 0]
 [0 7]]
The overall accuracy is: 1.0


/Users/jenchang/miniconda/envs/geo_env/lib/python3.7/site-packages/sklearn/utils/validation.py:70: FutureWarning: Pass labels=('emu', 'flamingo') as keyword args. From version 0.25 passing these as positional arguments will result in an error
  FutureWarning)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y_train_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_train</span><span class="p">,</span><span class="n">y_train_hat</span><span class="p">,</span><span class="n">categories</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The confusion matrix is:
[[46  1]
 [ 0 60]]
The overall accuracy is: 0.9906542056074766


/Users/jenchang/miniconda/envs/geo_env/lib/python3.7/site-packages/sklearn/utils/validation.py:70: FutureWarning: Pass labels=('emu', 'flamingo') as keyword args. From version 0.25 passing these as positional arguments will result in an error
  FutureWarning)
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">misclass_idx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_train</span><span class="o">!=</span><span class="n">y_train_hat</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">misclass_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">'The image '</span><span class="o">+</span><span class="n">filenames_train</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="s">' is misclassified'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">filenames_train</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The image 101_ObjectCategories/emu/image_0017.jpg is misclassified
</code></pre></div></div>

<p><img src="/IntroductionToImageAnalysis/images/Tutorial2_Classical_Machine_Learning_Boucheron_65_1.png" alt="png" /></p>

<h2 id="-your-turn--6"><span style="color:Green"> Your turn: </span></h2>
<p>What does this confusion matrix and accuracy tell you about the performance of the SVM classifier?</p>

<h3 id="section-43-training-a-multi-class-classifier">Section 4.3 Training a multi-class classifier</h3>
<p>We can use the same <code class="language-plaintext highlighter-rouge">svm.SVC</code> classifier for a multi-class (more than two classes) classification problem.  Many, but not all classifiers can be applied to binary and multi-class problems.</p>

<h2 id="-your-turn--7"><span style="color:Green"> Your turn: </span></h2>
<p>Use what you learned above to create a three-class classifier using input from the CalTech101 dataset.  The basic two-class code is copied into the cell below for ease of editing.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span>

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>

<span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>

<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">,</span><span class="n">categories</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The confusion matrix is:
[[6 0]
 [0 7]]
The overall accuracy is: 1.0


/Users/jenchang/miniconda/envs/geo_env/lib/python3.7/site-packages/sklearn/utils/validation.py:70: FutureWarning: Pass labels=('emu', 'flamingo') as keyword args. From version 0.25 passing these as positional arguments will result in an error
  FutureWarning)
</code></pre></div></div>

<h3 id="section-44-exploring-discriminative-capabilities-of-different-features">Section 4.4 Exploring discriminative capabilities of different features</h3>
<p>We can train an SVM using only a subset of the features that we have defined.  This is essentially an exploration of the discriminatory potential of different individual features or sets of features via ablation.  In the code below, we re-compute the feature matrices and label vectors for the <code class="language-plaintext highlighter-rouge">'emu'</code> versus <code class="language-plaintext highlighter-rouge">'flamingo'</code> problem.  Since we will be using subsets of features, we extract all features here and will use slicing to send a subset of features to the SVM classifier.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span>

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>

<span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">30</span><span class="p">],</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">30</span><span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Color features only:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Color features only:
The confusion matrix is:
[[4 2]
 [2 5]]
The overall accuracy is: 0.6923076923076923
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">[:,</span><span class="mi">30</span><span class="p">:</span><span class="mi">49</span><span class="p">],</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">[:,</span><span class="mi">30</span><span class="p">:</span><span class="mi">49</span><span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Region features only:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Region features only:
The confusion matrix is:
[[6 0]
 [1 6]]
The overall accuracy is: 0.9230769230769231
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">[:,</span><span class="mi">49</span><span class="p">:],</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">[:,</span><span class="mi">49</span><span class="p">:])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Texture features only:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Texture features only:
The confusion matrix is:
[[4 2]
 [1 6]]
The overall accuracy is: 0.7692307692307693
</code></pre></div></div>

<h2 id="-your-turn--8"><span style="color:Green"> Your turn: </span></h2>
<p>Choose two or more categories from the CalTech101 dataset that you think might be more or less amenable to discrimination using certain feature subsets.  Using those categories, explore the discriminative capabilities of different feature subsets.  The basic code for using color features only for the <code class="language-plaintext highlighter-rouge">'emu'</code> versus <code class="language-plaintext highlighter-rouge">'flamingo'</code> classification problem is copied into the cell below for ease of editing.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span>

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>

<span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">svm</span><span class="p">.</span><span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">30</span><span class="p">],</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">30</span><span class="p">])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Color features only:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Color features only:
The confusion matrix is:
[[4 2]
 [2 5]]
The overall accuracy is: 0.6923076923076923
</code></pre></div></div>

<h3 id="section-45-other-classifiers">Section 4.5 Other Classifiers</h3>
<p>There are many other classifiers available in the <code class="language-plaintext highlighter-rouge">sklearn</code> package, see https://scikit-learn.org/stable/user_guide.html for documentation.</p>

<h2 id="-your-turn--9"><span style="color:Green"> Your turn: </span></h2>
<p>Explore the capabilities of other classifiers.  If you don’t know where to start, some commonly referenced classifiers in the literature are</p>
<ul>
  <li>Linear Discriminant Analysis (LDA) available in <code class="language-plaintext highlighter-rouge">sklearn.discriminant_analysis</code> (Do a <code class="language-plaintext highlighter-rouge">from sklearn import discriminant_analysis</code> and then use <code class="language-plaintext highlighter-rouge">discriminant_analysis.LinearDiscriminantAnalysis</code>)</li>
  <li>k-Nearest Neighbors (KNN) available in <code class="language-plaintext highlighter-rouge">sklearn.neighbors</code> (Do a <code class="language-plaintext highlighter-rouge">from sklearn import neighbors</code> and then use <code class="language-plaintext highlighter-rouge">neighbors.KNeighborsClassifier</code>)</li>
  <li>Random Forest available in <code class="language-plaintext highlighter-rouge">sklearn.ensemble</code> (Do a <code class="language-plaintext highlighter-rouge">from sklearn import ensemble</code> and then use <code class="language-plaintext highlighter-rouge">ensemble.RandomForestClassifier</code></li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">discriminant_analysis</span>
<span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span>

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>

<span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">discriminant_analysis</span><span class="p">.</span><span class="n">LinearDiscriminantAnalysis</span><span class="p">()</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The confusion matrix is:
[[5 1]
 [3 4]]
The overall accuracy is: 0.6923076923076923
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">neighbors</span>
<span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span>

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>

<span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">.</span><span class="n">KNeighborsClassifier</span><span class="p">()</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The confusion matrix is:
[[6 0]
 [1 6]]
The overall accuracy is: 0.9230769230769231
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">ensemble</span>
<span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="s">'emu'</span><span class="p">,</span> <span class="s">'flamingo'</span><span class="p">)</span>

<span class="c1"># instantiate empty feature matrices and label vectors
</span><span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">97</span><span class="p">),</span><span class="nb">float</span><span class="p">)</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">category</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span> <span class="c1"># loop over categories
</span>    <span class="n">ims</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'101_ObjectCategories/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.jpg'</span><span class="p">))</span> <span class="c1"># list of images
</span>    <span class="n">ans</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'Annotations/'</span><span class="o">+</span><span class="n">category</span><span class="o">+</span><span class="s">'/*.mat'</span><span class="p">))</span> <span class="c1"># corresponding list of annotations
</span>    <span class="n">N_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">*</span><span class="mf">0.9</span><span class="p">)</span> <span class="c1"># compute number of training samples
</span>    <span class="n">N_test</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span> <span class="o">-</span> <span class="n">N_train</span> <span class="c1"># compute number of testing samples
</span>    <span class="k">for</span> <span class="n">f</span><span class="p">,</span><span class="n">im_filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ims</span><span class="p">):</span> <span class="c1"># loop over all images
</span>        <span class="n">an_filename</span> <span class="o">=</span> <span class="n">ans</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="c1"># grab corresponding annotation filename
</span>        <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">imageio</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_filename</span><span class="p">))</span> <span class="c1"># read in image
</span>        <span class="n">ann</span> <span class="o">=</span> <span class="n">spio</span><span class="p">.</span><span class="n">loadmat</span><span class="p">(</span><span class="n">an_filename</span><span class="p">)</span> <span class="c1"># load annotation
</span>        <span class="n">r</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">skimage</span><span class="p">.</span><span class="n">draw</span><span class="p">.</span><span class="n">polygon</span><span class="p">(</span><span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">1</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="n">ann</span><span class="p">[</span><span class="s">'obj_contour'</span><span class="p">][</span><span class="mi">0</span><span class="p">,:]</span><span class="o">+</span><span class="n">ann</span><span class="p">[</span><span class="s">'box_coord'</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                                   <span class="p">(</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># compute annotation polygon
</span>        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">im</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="c1"># initialize annotation mask
</span>        <span class="n">mask</span><span class="p">[</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># define annotation mask
</span>        <span class="n">f_rgb</span><span class="p">,</span><span class="n">fnames_rgb</span> <span class="o">=</span> <span class="n">extract_color_features_rgb</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract RGB features
</span>        <span class="n">f_hsv</span><span class="p">,</span><span class="n">fnames_hsv</span> <span class="o">=</span> <span class="n">extract_color_features_hsv</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract HSV features
</span>        <span class="n">f_region</span><span class="p">,</span><span class="n">fnames_region</span> <span class="o">=</span> <span class="n">extract_region_features</span><span class="p">(</span><span class="n">mask</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="c1"># extract region features
</span>        <span class="n">f_texture</span><span class="p">,</span><span class="n">fnames_texture</span> <span class="o">=</span> <span class="n">extract_texture_features</span><span class="p">(</span><span class="n">im</span><span class="p">,</span><span class="n">mask</span><span class="p">)</span> <span class="c1"># extract texture features
</span>        <span class="k">if</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">N_train</span><span class="p">:</span> <span class="c1"># append to training feature matrix and label vector
</span>            <span class="n">X_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_train</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_train</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># append to testing feature matrix and label vector
</span>            <span class="n">X_test</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">X_test</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">f_rgb</span><span class="p">,</span><span class="n">f_hsv</span><span class="p">,</span><span class="n">f_region</span><span class="p">,</span><span class="n">f_texture</span><span class="p">))))</span>
            <span class="n">y_test</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>

<span class="n">Xn_train</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
<span class="n">Xn_test</span> <span class="o">=</span> <span class="n">normalize_feature_columns</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">mn</span><span class="p">)</span>

<span class="n">clf</span> <span class="o">=</span> <span class="n">ensemble</span><span class="p">.</span><span class="n">RandomForestClassifier</span><span class="p">()</span>
<span class="n">clf</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Xn_train</span><span class="p">,</span><span class="n">y_train</span><span class="p">)</span>
<span class="n">y_test_hat</span> <span class="o">=</span> <span class="n">clf</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xn_test</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">metrics</span><span class="p">.</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span><span class="n">y_test_hat</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The confusion matrix is:'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diag</span><span class="p">(</span><span class="n">C</span><span class="p">).</span><span class="nb">sum</span><span class="p">().</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="n">C</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">'The overall accuracy is: '</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">acc</span><span class="p">))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The confusion matrix is:
[[6 0]
 [0 7]]
The overall accuracy is: 1.0
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

        
      </section>

      <footer class="page__meta">
        
        


        
      </footer>

      

      

    </div>

    
  </article>

  
  
</div>
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form onsubmit="return googleCustomSearchExecute();" id="cse-search-box-form-id">
    <input type="search" id="cse-search-input-box-id" aria-placeholder="Enter your search term..." class="search-input" tabindex="-1" placeholder="Enter your search term..." />
    </form>
    <div id="results" class="results">
        <gcse:searchresults-only></gcse:searchresults-only>
    </div></div>

      </div>
    
    
    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    
    
      <li><a href="https://twitter.com/isugif"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
    
    
    
      <li><a href="https://github.com/https://github.com/isugenomics"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
    
    
    
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Geospatial Workbook</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.13/js/all.js"></script>


<script>
  (function () {
    var cx = '009853197685285203469:nsvri1pa88d';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();

  function googleCustomSearchExecute() {
    var input = document.getElementById('cse-search-input-box-id');
    var element = google.search.cse.element.getElement('searchresults-only0');
    if (input.value == '') {
      element.clearAllResults();
    } else {
      element.execute(input.value);
    }
    return false;
  }

  
</script>




<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" defer
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>




  </body>
</html>
